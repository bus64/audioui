{
    "src_dir": "presets",
    "files": [
        {
            "file_path": "base_preset.py",
            "content": "#File:  audio/presets/base_preset.py \u00a9 2025 projectemergence. All rights reserved.\n# File: src/core/audio/presets/base_preset.py\n\nfrom abc import ABC, abstractmethod\nimport math, time\nfrom pyo import (Fader, Pan, SigTo, Freeverb, Chorus, ButBP, ButLP)\n\nclass BasePreset(ABC):\n    def __init__(\n        self,\n        intensity: float | list[float] = 0.7,\n        duration:  float | None       = 2.0,\n        freq1:     float | None       = None,\n        freq2:     float | None       = None,\n        pan_pos:   float              = 0.0,\n        stereo_w:  float              = 0.0,\n        enable_reverb: bool           = False,\n        enable_chorus: bool           = False,\n        enable_filter: bool           = False,\n        filt_freq: float              = 1200,\n        **extra\n    ):\n        # allow either a single float or per-note list\n        if isinstance(intensity, list):\n            # keep full list for subclass\n            self._per_note_intensities = intensity\n            base_int = max(intensity) if intensity else 0.0\n        else:\n            self._per_note_intensities = None\n            base_int = intensity\n\n        self.intensity    = max(base_int, 0.0)\n        self.duration     = duration\n        self.freq1, self.freq2 = freq1, freq2\n        self._pan_pos     = max(min(pan_pos, 1), -1)\n        self.stereo_w     = max(min(stereo_w, 1), 0)\n        self.enable_reverb  = enable_reverb\n        self.enable_chorus  = enable_chorus\n        self.enable_filter  = enable_filter\n        self.filt_freq      = filt_freq\n        self._keep_alive = []               # guard vs GC\n\n    def _env(self, fade=.005) -> Fader:\n        dur = self.duration or 0\n        return Fader(fadein=fade, fadeout=fade*4, dur=dur, mul=self.intensity)\n\n    def _fx_chain(self, sig):\n        if self.enable_filter:\n            sig = ButLP(sig, freq=self.filt_freq)\n        if self.enable_chorus and self.stereo_w:\n            sig = Chorus(sig, depth=.8*self.stereo_w, feedback=.25, bal=.5)\n        if self.enable_reverb:\n            sig = Freeverb(sig, size=.8, bal=.35)\n        if self._pan_pos or self.stereo_w:\n            sig = Pan(sig, outs=2, pan=self._pan_pos)\n        return sig\n\n    def _keep(self, *objs):\n        self._keep_alive.extend(objs)\n        return objs[0] if objs else None\n\n    @abstractmethod\n    def _build(self):\n        \"\"\"\n        Subclasses must return either\n          \u2022 a single Pyo object (dry signal), or\n          \u2022 a list of (Fader, Pyo-object) tuples for sequences.\n        \"\"\"\n\n    def play(self):\n        built = self._build()\n\n        # if a sequence of (fader,signal), schedule them:\n        if isinstance(built, list):\n            for fader, sig in built:\n                fader.play()\n                out = self._fx_chain(sig)\n                self._keep(out).out()\n                # wait for this note\u2019s duration before next\n                time.sleep(fader.dur)\n            return built\n\n        # otherwise single-shot as before\n        dry = built\n        wet = self._fx_chain(dry)\n        self._keep(wet).out()\n        return wet\n    def _sweep(self, start_freq, end_freq, duration):\n        \"\"\"\n        Glide from start_freq to end_freq over a given duration.\n        This can be useful for smooth transitions in sound design.\n\n        Args:\n            start_freq (float): Starting frequency for the glide.\n            end_freq (float): Ending frequency for the glide.\n            duration (float): Duration for the glide in seconds.\n\n        Returns:\n            float: The frequency value after applying the glide.\n        \"\"\"\n        step = (end_freq - start_freq) / duration\n        current_freq = start_freq\n        time_step = 0.01  # Update every 10ms, you can adjust this based on your needs\n\n        # Apply the glide over time\n        while current_freq != end_freq:\n            current_freq += step * time_step\n            if abs(current_freq - end_freq) < abs(step * time_step):\n                current_freq = end_freq\n            time.sleep(time_step)  # Simulate time delay for smooth transition\n        return current_freq"
        },
        {
            "file_path": "bass.py",
            "content": "# File: src/core/audio/presets/bass.py \u00a9 2025 projectemergence. All rights reserved.\n# Defines the Bass preset, with optional distortion. _build() added for architecture support.\n\nfrom pyo import Sine, Fader, Disto\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Bass(BasePreset):\n    def __init__(\n        self,\n        intensity=1.0,\n        duration=0.65,\n        base_freq=733.57,\n        fade_in=0.01,\n        fade_out=0.03,\n        tone_freq_ratio=20.0,\n        tone_mul_factor=0.68,\n        dist_drive=0.81,\n        dist_slope=1.0,\n        dist_mul_factor=0.93,\n    ):\n        super().__init__(intensity * 2, duration)\n        # core inputs\n        self.base_freq = 733.57\n        # fader constants\n        self.fade_in = 0.01\n        self.fade_out = 0.03\n        # tone constants\n        self.tone_freq_ratio = 20.0\n        self.tone_mul_factor = 0.68\n        # distortion constants\n        self.dist_drive = 0.81\n        self.dist_slope = 1.0\n        self.dist_mul_factor = 0.93\n\n    def _build(self):\n        # use named attributes everywhere instead of literals\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration * 2,\n            mul=self.intensity\n        )\n        tone = Sine(\n            freq=self.base_freq * self.tone_freq_ratio,\n            mul=fader * self.tone_mul_factor\n        )\n        distorted = Disto(\n            tone,\n            drive=self.dist_drive,\n            slope=self.dist_slope,\n            mul=self.intensity * self.dist_mul_factor\n        )\n        self.chain = {\"fader\": fader, \"tone\": tone, \"distorted\": distorted}\n        return self.chain\n\n    def play(self):\n        chain = self._build()\n        chain[\"fader\"].play()\n        chain[\"distorted\"].out()\n        return chain\n"
        },
        {
            "file_path": "big_kick.py",
            "content": "# File: audio/presets/big_kick.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n# \u00a9 2025 projectemergence \u2013 v2\n\n\"\"\"\nBigKick 2.0 \u2013 modern electronic kick\n\u2022 body: exponential sine sweep for punch\n\u2022 click: tight noise burst with band-pass\n\u2022 sub: optional low sine layer\n\u2022 gating and HPF to remove noise floor\n\u2022 antialias filtering around waveshaper\n\"\"\"\n\nfrom pyo import Sine, Noise, ButBP, ButHP, Fader, Clip, Biquad, Gate\nfrom core.audio.presets.base_preset import BasePreset\n\nclass BigKick(BasePreset):\n    def __init__(\n        self,\n        intensity=0.68,\n        duration=0.6,\n        freq1=160,\n        freq2=45,\n        click_len=0.015,\n        click_freq=5000,\n        add_sub=True,\n        soft_clip=True,\n        gate_thresh=0.001,\n        body_env_fadein=0.002,\n        body_sweep_ratio=0.89,\n        click_env_fadein=0.0005,\n        click_env_fadeout_ratio=0.7,\n        click_mul_factor=0.35,\n        click_bp_q=10.0,\n        sub_freq_ratio=0.5,\n        sub_mul_factor=0.5,\n        lpf_freq=20000.0,\n        lpf_q=0.707,\n        lpf_type=1,\n        clip_min=-0.9,\n        clip_max=0.9,\n        hpf_freq=20.0,\n        hpf_q=0.707,\n        hpf_type=2,\n        **kw\n    ):\n        kw.setdefault('stereo_w', 0.0)\n        kw.setdefault('enable_reverb', False)\n        super().__init__(intensity=0.68,\n                         duration=0.6,\n                         freq1=160,\n                         freq2=45,\n                         **kw)\n\n        # click parameters\n        self.click_len = 0.015\n        self.click_freq = 5000\n\n        # behavior flags\n        self.add_sub = True\n        self.soft_clip = True\n        self.gate_thresh = 0.001\n\n        # body envelope / sweep\n        self.body_env_fadein = 0.002\n        self.body_sweep_ratio = 0.89\n\n        # click envelope\n        self.click_env_fadein = 0.0005\n        self.click_env_fadeout_ratio = 0.7\n        self.click_mul_factor = 0.35\n        self.click_bp_q = 10.0\n\n        # sub oscillator\n        self.sub_freq_ratio = 0.5\n        self.sub_mul_factor = 0.5\n\n        # soft-clip / antialias filter\n        self.lpf_freq = 20000.0\n        self.lpf_q = 0.707\n        self.lpf_type = 1\n        self.clip_min = -0.9\n        self.clip_max = 0.9\n\n        # final high-pass filter\n        self.hpf_freq = 20.0\n        self.hpf_q = 0.707\n        self.hpf_type = 2\n\n    def _make_body(self, env):\n        # exponential sweep for psycho-acoustic punch\n        glide = self._sweep(\n            self.freq1,\n            self.freq2,\n            self.duration * self.body_sweep_ratio,\n            exp=True\n        )\n        return Sine(freq=glide, mul=env)\n\n    def _make_click(self):\n        env = Fader(\n            fadein=self.click_env_fadein,\n            fadeout=self.click_len * self.click_env_fadeout_ratio,\n            dur=self.click_len,\n            mul=self.intensity * self.click_mul_factor\n        ).play()\n        noise = Noise(mul=env)\n        return ButBP(noise, freq=self.click_freq, q=self.click_bp_q)\n\n    def _make_sub(self, env):\n        sub_freq = max(self.freq2 * self.sub_freq_ratio, 20.0)\n        return Sine(freq=sub_freq, mul=env * self.sub_mul_factor)\n\n    def _build(self):\n        # body envelope\n        body_env = self._env(self.body_env_fadein)\n\n        # components\n        parts = [\n            self._make_body(body_env),\n            self._make_click()\n        ]\n        if self.add_sub:\n            parts.append(self._make_sub(body_env))\n\n        mix = sum(parts)\n\n        if self.soft_clip:\n            # antialias LPF before clipping\n            mix = Biquad(\n                mix,\n                freq=self.lpf_freq,\n                q=self.lpf_q,\n                type=self.lpf_type\n            )\n            mix = Clip(mix, min=self.clip_min, max=self.clip_max)\n\n        # gate to remove residual noise\n        gated = Gate(mix, thresh=self.gate_thresh)\n\n        # high-pass to remove subsonic rumble\n        return Biquad(\n            gated,\n            freq=self.hpf_freq,\n            q=self.hpf_q,\n            type=self.hpf_type\n        )\n"
        },
        {
            "file_path": "cello.py",
            "content": "# File: src/core/audio/presets/cello.py \u00a9 2025 projectemergence. All rights reserved.\n# Defines a resonant cello tone. _build() added for architecture support.\n\nfrom pyo import Sine, Fader, Freeverb\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Cello(BasePreset):\n    def __init__(\n        self,\n        intensity=0.5,\n        duration=1.19,\n        base_freq=216.0,\n        freq_multiplier=3.0,\n        fade_in=0.2,\n        fade_out=4.29,\n        dur_multiplier=2.08,\n        fader_mul_factor=0.95,\n        tone_mul_factor=2.0,\n        reverb_input_div=2.0,\n        reverb_size=0.76,\n        reverb_bal=0.93,\n    ):\n        super().__init__(intensity, duration)\n        # core inputs\n        self.base_freq = 20.0 * freq_multiplier\n\n        # fader settings\n        self.fade_in = 0.2\n        self.fade_out = 4.29\n        self.dur_multiplier = 2.08\n        self.fader_mul_factor = 0.95\n\n        # tone settings\n        self.tone_mul_factor = 2.0\n\n        # reverb settings\n        self.reverb_input_div = 2.0\n        self.reverb_size = 0.76\n        self.reverb_bal = 0.93\n\n    def _build(self):\n        # amplitude envelope\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration * self.dur_multiplier,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        # core sine tone\n        tone = Sine(\n            freq=self.base_freq,\n            mul=fader * self.tone_mul_factor\n        )\n        # reverb effect\n        reverb = Freeverb(\n            tone / self.reverb_input_div,\n            size=self.reverb_size,\n            bal=self.reverb_bal\n        )\n        self.chain = {\"fader\": fader, \"tone\": tone, \"reverb\": reverb}\n        return self.chain\n\n    def play(self):\n        chain = self._build()\n        chain[\"fader\"].play()\n        chain[\"reverb\"].out()\n        return chain\n"
        },
        {
            "file_path": "chorus.py",
            "content": "# File: core/audio/presets/chorus.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\nfrom pyo import Noise, Chorus\nfrom core.audio.presets.base_preset import BasePreset\n\nclass ChorusPreset(BasePreset):\n    \"\"\"A simple chorus/noise layer that can thicken the drone.\"\"\"\n    def __init__(self, *, visual_metric: float = 0.0):\n        super().__init__()\n        self.depth = 1.0 + visual_metric * 0.5\n\n    def play(self):\n        return Chorus(Noise(mul=0.1),\n                      depth=self.depth,\n                      feedback=0.6,\n                      bal=0.5).out()\n    def _build(self):\n        # fade-in only once, then hold\n        env = Fader(fadein=0.1, fadeout=0.5, dur=0.0, mul=0.1).play()\n        # noise source into chorus\n        noise = Noise(mul=env)\n        return Chorus(noise, depth=self.depth, feedback=0.6, bal=0.5)\n"
        },
        {
            "file_path": "clarinet.py",
            "content": "# File: src/core/audio/presets/clarinet.py \u00a9 2025 projectemergence. All rights reserved.\n# Defines a clarinet sound with filter and distortion. _build() added for architecture support.\n\nfrom pyo import Sine, Fader, Disto, ButLP\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Clarinet(BasePreset):\n    def __init__(\n        self,\n        intensity=0.83,\n        duration=2.2,\n        base_freq=20.0,\n        fade_in=0.05,\n        fade_out=0.5,\n        fader_mul_factor=0.26,\n        dist_drive=0.6,\n        dist_slope=0.3,\n        dist_mul_factor=1.0,\n        filter_freq=800.0,\n    ):\n        super().__init__(intensity, duration)\n        # core\n        self.base_freq = 20.0\n        # fader settings\n        self.fade_in = 0.05\n        self.fade_out = 0.5\n        self.fader_mul_factor = 0.26\n        # distortion settings\n        self.dist_drive = 0.6\n        self.dist_slope = 0.3\n        self.dist_mul_factor = 1.0\n        # filter settings\n        self.filter_freq = 800.0\n\n    def _build(self):\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        tone = Sine(\n            freq=self.base_freq,\n            mul=fader\n        )\n        distorted = Disto(\n            tone,\n            drive=self.dist_drive,\n            slope=self.dist_slope,\n            mul=self.dist_mul_factor\n        )\n        filtered = ButLP(\n            distorted,\n            freq=self.filter_freq\n        )\n        self.chain = {\n            \"fader\": fader,\n            \"tone\": tone,\n            \"distorted\": distorted,\n            \"filtered\": filtered\n        }\n        return self.chain\n\n    def play(self):\n        chain = self._build()\n        chain[\"fader\"].play()\n        chain[\"filtered\"].out()\n        return chain\n"
        },
        {
            "file_path": "digital_snap.py",
            "content": "# File: src/core/audio/presets/digital_snap.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nDigitalSnap \u2013 hyper-tight click percussion with bit-crush and comb-style delay.\n\"\"\"\n\nfrom pyo import Noise, Fader, Degrade, SmoothDelay, ButHP\nfrom core.audio.presets.base_preset import BasePreset\n\nclass DigitalSnap(BasePreset):\n    def __init__(\n        self,\n        intensity=0.8,\n        duration=1.01,\n        bit_depth=6,\n        sr_scale=0.0,\n        comb_delay=0.04,\n        comb_feedback=0.0,\n        hpf_freq=138.93,\n        fade_in=0.001,\n        fade_out=0.02,\n        crossfade=0.01,\n        **kw\n    ):\n        kw.setdefault('stereo_w', 0.0)\n        kw.setdefault('enable_reverb', False)\n        super().__init__(intensity=0.8, duration=1.01, **kw)\n\n        # bit-crusher params\n        self.bit_depth = 6\n        self.sr_scale = 0.0\n\n        # comb-style delay params (delay + feedback)\n        self.comb_delay = 0.04\n        self.comb_feedback = 0.0\n        self.crossfade = 0.01\n\n        # cleanup filter\n        self.hpf_freq = 138.93\n\n        # envelope params\n        self.fade_in = 0.001\n        self.fade_out = 0.02\n\n        # storage for the signal chain\n        self.chain = {}\n\n    def _build(self):\n        # 1) click envelope\n        env = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity\n        ).play()\n\n        # 2) white-noise click\n        noise = Noise(mul=env)\n\n        # 3) bit-crusher\n        crushed = Degrade(noise,\n                          bitdepth=self.bit_depth,\n                          srscale=self.sr_scale)\n\n        # 4) comb-style delay via SmoothDelay (delay + feedback) :contentReference[oaicite:1]{index=1}\n        combed = SmoothDelay(crushed,\n                             delay=self.comb_delay,\n                             feedback=self.comb_feedback,\n                             crossfade=0.01)\n\n        # 5) high-pass cleanup\n        cleaned = ButHP(combed, freq=self.hpf_freq)\n\n        self.chain = {\n            \"env\": env,\n            \"crushed\": crushed,\n            \"combed\": combed,\n            \"cleaned\": cleaned\n        }\n        return cleaned\n\n    def play(self):\n        out = self._build()\n        out.out()\n        return self.chain\n\nif __name__ == \"__main__\":\n    DigitalSnap().play()\n"
        },
        {
            "file_path": "drone.py",
            "content": "# File: core/audio/presets/drone.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\nfrom pyo import Fader, Sine, SigTo\nfrom core.audio.presets.base_preset import BasePreset\n\nclass DronePreset(BasePreset):\n    \"\"\"Continuous drone whose level & pitch track settled_ratio & visual_metric.\"\"\"\n    def __init__(self, *, settled_ratio: float = 0.0, visual_metric: float = 0.0):\n        super().__init__()  # uses default intensity/duration\n        self.settled_ratio = settled_ratio\n        self.visual_metric = visual_metric\n\n    def play(self):\n        env  = Fader(fadein=0.5, fadeout=0.1, dur=0, mul=self.settled_ratio).play()\n        freq = SigTo(value=200 + self.visual_metric * 800, time=0.1)\n        return Sine(freq=freq, mul=env * 0.3).out()\n    def _build(self):\n        # one-liner envelope \u00d7 drone\n        env = Fader(fadein=0.5, fadeout=0.1, dur=0.0, mul=self.intensity).play()\n        freq = SigTo(value=200 + self.visual_metric * 800, time=0.1)\n        return Sine(freq=freq, mul=env * 0.3)"
        },
        {
            "file_path": "fm_bell_cluster.py",
            "content": "# File: src/core/audio/presets/fm_bell_cluster.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nFMBellCluster \u2013 FM-based bell cluster with feedback, chorus and reverb.\n\"\"\"\n\nfrom pyo import FM, Chorus, Freeverb, Fader\nfrom core.audio.presets.base_preset import BasePreset\n\nclass FMBellCluster(BasePreset):\n    def __init__(\n        self,\n        intensity=0.6,\n        duration=4.0,\n        carrier_freq=330.0,\n        mod_ratio=2.0,\n        index=5.0,\n        chorus_depth=1.2,\n        chorus_feedback=0.3,\n        reverb_size=0.8,\n        reverb_bal=0.4,\n        fade_in=0.01,\n        fade_out=1.0,\n        **kw\n    ):\n        kw.setdefault('enable_reverb', True)\n        kw.setdefault('stereo_w', 0.2)\n        super().__init__(intensity=intensity, duration=duration, **kw)\n\n        # FM params\n        self.carrier_freq = carrier_freq\n        self.mod_ratio = mod_ratio\n        self.index = index\n\n        # chorus\n        self.chorus_depth = chorus_depth\n        self.chorus_feedback = chorus_feedback\n\n        # reverb\n        self.reverb_size = reverb_size\n        self.reverb_bal = reverb_bal\n\n        # envelope\n        self.fade_in = fade_in\n        self.fade_out = fade_out\n\n    def _build(self):\n        env = Fader(fadein=self.fade_in, fadeout=self.fade_out,\n                    dur=self.duration, mul=self.intensity).play()\n        # FM carrier/modulator\n        bell = FM(carrier=self.carrier_freq,\n                  ratio=self.mod_ratio,\n                  index=self.index,\n                  mul=env)\n        # add richness\n        ch = Chorus(bell, depth=self.chorus_depth,\n                    feedback=self.chorus_feedback)\n        # space\n        rv = Freeverb(ch, size=self.reverb_size,\n                      bal=self.reverb_bal)\n        self.chain = {\"env\": env, \"bell\": bell, \"chorus\": ch, \"reverb\": rv}\n        return rv\n\n    def play(self):\n        out = self._build()\n        out.out()\n        return self.chain\n"
        },
        {
            "file_path": "general_presets.py",
            "content": "# File: core/audio/presets/general_presets.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\nfrom core.audio.presets.base_preset import BasePreset\nfrom pyo import Fader, Sine, Noise, SigTo, Chorus, Freeverb, ButLP, IRPulse\n\nclass DronePreset(BasePreset):\n    \"\"\"Continuous drone whose level & pitch track settled_ratio & visual_metric.\"\"\"\n    def __init__(self, *, settled_ratio: float = 0.0, visual_metric: float = 0.0):\n        super().__init__()\n        self.settled_ratio = settled_ratio\n        self.visual_metric = visual_metric\n\n    def play(self):\n        # one-liner envelope \u00d7 drone\n        env = Fader(fadein=0.5, fadeout=0.1, dur=0, mul=self.settled_ratio).play()\n        freq = SigTo(value=200 + self.visual_metric * 800, time=0.1)\n        return Sine(freq=freq, mul=env*0.3).out()\n\nclass ChorusPreset(BasePreset):\n    \"\"\"A simple chorus/noise layer that can thicken the drone.\"\"\"\n    def __init__(self, *, visual_metric: float = 0.0):\n        super().__init__()\n        self.depth = 1.0 + visual_metric * 0.5\n\n    def play(self):\n        return Chorus(Noise(mul=0.1), depth=self.depth, feedback=0.6, bal=0.5).out()\n\nclass SquareFallPreset(BasePreset):\n    \"\"\"Burst of harmonics into a comb filter (square-fall).\"\"\"\n    def __init__(self, *, intensity: float = 0.5, freq: float = 200, harmonics: int = 6):\n        super().__init__()\n        self.intensity, self.freq, self.harmonics = intensity, freq, harmonics\n\n    def play(self):\n        env   = Fader(fadein=0.01, fadeout=0.25, dur=0.25, mul=self.intensity).play()\n        burst = sum(Sine(freq=self.freq*(i+1), mul=env/(i+1)) for i in range(self.harmonics))\n        IRPulse(input=burst, order=2048).out()\n        return burst\n\nclass MetallicRainPreset(BasePreset):\n    \"\"\"Quick metallic drop using band-pass and two oscillators.\"\"\"\n    def __init__(self, *, intensity: float = 0.7, base_freq: float = 600,\n                 visual_metric: float = 0.5, fall_speed: float = 1.0):\n        super().__init__()\n        self.intensity, self.visual_metric = intensity, visual_metric\n        self.base_freq = base_freq + visual_metric * 200\n        self.fall_speed = fall_speed\n\n    def play(self):\n        dur = max(0.1, 0.5 - self.fall_speed * 0.1)\n        env = Fader(fadein=dur/5, fadeout=dur*0.8, dur=dur, mul=self.intensity).play()\n        mod = Sine(freq=5, mul=self.base_freq * 0.02 * self.visual_metric, add=self.base_freq)\n        osc1 = Sine(freq=mod, mul=env).out()\n        osc2 = Sine(freq=self.base_freq * 1.5, mul=env*0.5).out()\n        ButLP(osc1+osc2, freq=self.base_freq).out()\n        return osc1\n"
        },
        {
            "file_path": "guitar.py",
            "content": "# File: src/core/audio/presets/guitar.py \u00a9 2025 projectemergence. All rights reserved.\n# Simulates a plucked sine loop guitar. _build() added for architecture support.\n\nfrom pyo import SineLoop, Fader, Chorus\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Guitar(BasePreset):\n    def __init__(\n        self,\n        intensity=1.0,\n        duration=0.18,\n        base_freq=220.0,\n        fade_in=0.01,\n        fade_out=0.36,\n        fader_mul_factor=0.57,\n        loop_feedback=0.07,\n        chorus_depth=0.44,\n        chorus_feedback=0.14,\n        chorus_bal=0.14,\n    ):\n        super().__init__(intensity, duration)\n        # core\n        self.base_freq = 220.0\n        # fader settings\n        self.fade_in = 0.01\n        self.fade_out = 0.36\n        self.fader_mul_factor = 0.57\n        # sine-loop settings\n        self.loop_feedback = 0.07\n        # chorus settings\n        self.chorus_depth = 0.44\n        self.chorus_feedback = 0.14\n        self.chorus_bal = 0.14\n\n    def _build(self):\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        tone = SineLoop(\n            freq=self.base_freq,\n            feedback=self.loop_feedback,\n            mul=fader\n        )\n        chorus = Chorus(\n            tone,\n            depth=self.chorus_depth,\n            feedback=self.chorus_feedback,\n            bal=self.chorus_bal\n        )\n        self.chain = {\"fader\": fader, \"tone\": tone, \"chorus\": chorus}\n        return self.chain\n\n    def play(self):\n        chain = self._build()\n        chain[\"fader\"].play()\n        chain[\"chorus\"].out()\n        return chain\n"
        },
        {
            "file_path": "harmonic_swarm.py",
            "content": "# File: src/core/audio/presets/harmonic_swarm.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nHarmonicSwarm \u2013 multiple detuned partials with dynamic panning and delay feedback.\n\"\"\"\n\nfrom random import uniform\nfrom pyo import Sine, Fader, Delay, Pan, Sine as LFO\nfrom core.audio.presets.base_preset import BasePreset\n\nclass HarmonicSwarm(BasePreset):\n    def __init__(\n        self,\n        intensity=0.5,\n        duration=0,   \n        base_freq=110.0,\n        num_voices=6,\n        freq_ratio=1.01,\n        pan_rate=0.05,\n        pan_depth=1.0,\n        delay_times=(0.1,0.2,0.3),\n        delay_feedback=0.3,\n        delay_mul=0.4,\n        fade_in=2.0,\n        fade_out=2.0,\n        **kw\n    ):\n        kw.setdefault('enable_reverb', True)\n        kw.setdefault('stereo_w', 0.3)\n        super().__init__(intensity=intensity, duration=duration, **kw)\n\n        # core\n        self.base_freq = base_freq\n        self.num_voices = num_voices\n        self.freq_ratio = freq_ratio\n\n        # panning LFO\n        self.pan_rate = pan_rate\n        self.pan_depth = pan_depth\n\n        # delay\n        self.delay_times = delay_times\n        self.delay_feedback = delay_feedback\n        self.delay_mul = delay_mul\n\n        # envelope\n        self.fade_in = fade_in\n        self.fade_out = fade_out\n\n    def _build(self):\n        # long fade for smooth crossfade\n        gate = Fader(fadein=self.fade_in, fadeout=self.fade_out,\n                     dur=self.duration, mul=self.intensity).play()\n\n        # create voices\n        voices = []\n        for i in range(self.num_voices):\n            detune = self.base_freq * (self.freq_ratio**i)\n            osc = Sine(freq=detune, mul=gate/self.num_voices)\n            pan_lfo = LFO(freq=self.pan_rate + uniform(-0.01,0.01),\n                          mul=self.pan_depth/2, add=0.5)\n            voices.append(Pan(osc, pan=pan_lfo))\n\n        mix = sum(voices)\n        # build one Delay per tap time and sum them\n        delays = []\n        for dt in self.delay_times:\n            delays.append(Delay(mix,\n                                delay=dt,\n                                feedback=self.delay_feedback,\n                                mul=self.delay_mul))\n        delayed = sum(delays)\n        self.chain = {\"gate\": gate, \"voices\": voices, \"delayed\": delayed}\n        return delayed\n\n    def play(self):\n        out = self._build()\n        out.out()\n        return self.chain\n"
        },
        {
            "file_path": "hi_hat.py",
            "content": "# File: src/core/audio/presets/hi_hat.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nFile: audio/presets/hi_hat.py\n\u00a9 2025 projectemergence. All rights reserved.\n\nDefines the Hi-Hat preset.\nSimulates a hi-hat using filtered noise with a short burst envelope.\nAdoptez une vision tourn\u00e9e vers l\u2019avenir!\n\"\"\"\n\nfrom pyo import Noise, Fader, ButHP\nfrom core.audio.presets.base_preset import BasePreset\n\nclass HiHat(BasePreset):\n    def __init__(\n        self,\n        intensity=0.76,\n        duration=1.85,\n        cutoff=5654.76,\n        fade_in=0.005,\n        fade_out=0.21,\n        fader_mul_factor=0.0,\n        **kw\n    ):\n        kw.setdefault('stereo_w', 0.0)\n        kw.setdefault('enable_reverb', False)\n        super().__init__(intensity=0.76, duration=1.85, **kw)\n        # filter cutoff\n        self.cutoff = 5654.76\n        # envelope settings\n        self.fade_in = 0.005\n        self.fade_out = 0.21\n        self.fader_mul_factor = 0.0\n\n    def _build(self):\n        # short burst envelope\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        noise = Noise(mul=fader)\n        hi_hat = ButHP(noise, freq=self.cutoff)\n        self.chain = {\"fader\": fader, \"noise\": noise, \"hi_hat\": hi_hat}\n        return self.chain\n\n    def play(self):\n        chain = self._build()\n        chain[\"fader\"].play()\n        chain[\"hi_hat\"].out()\n        return chain\n\nif __name__ == \"__main__\":\n    HiHat().play()\n"
        },
        {
            "file_path": "laser.py",
            "content": "# File: src/core/audio/presets/laser.py \u00a9 2025 projectemergence. All rights reserved.\n# Futuristic laser sound with FM. _build() added for architecture support.\n\nfrom pyo import Sine, Fader\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Laser(BasePreset):\n    def __init__(\n        self,\n        intensity=0.9,\n        duration=0.3,\n        base_freq=800.0,\n        mod_depth=50.0,\n        mod_rate=20.0,\n        fade_in=0.005,\n        fade_out=0.2,\n        fader_mul_factor=1.0,\n    ):\n        super().__init__(intensity, duration)\n        # core\n        self.base_freq = base_freq\n        self.mod_depth = mod_depth\n        self.mod_rate = mod_rate\n        # envelope settings\n        self.fade_in = fade_in\n        self.fade_out = fade_out\n        self.fader_mul_factor = fader_mul_factor\n\n    def _build(self):\n        # amplitude envelope\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        # modulator oscillator\n        mod = Sine(freq=self.mod_rate, mul=self.mod_depth)\n        # frequency-modulated carrier\n        modulated_freq = self.base_freq + mod\n        laser = Sine(freq=modulated_freq, mul=fader)\n        self.chain = {\"fader\": fader, \"mod\": mod, \"laser\": laser}\n        return self.chain\n\n    def play(self):\n        chain = self._build()\n        chain[\"fader\"].play()\n        chain[\"laser\"].out()\n        return chain\n"
        },
        {
            "file_path": "metallic_rain.py",
            "content": "# File: audio/presets/metallic_rain.py \u00a9 2025 projectemergence. All rights reserved.\n# \u00a9 2025 projectemergence\n#!/usr/bin/env python3\n\"\"\"\nMetallicRain \u2013 spectral drizzle with stereo drift and tail.\n(Fixed kw duplication 2025-04-23.)\n\"\"\"\n\nimport random, time, threading\nfrom pyo import Noise, ButBP, Sine, Fader, Mix\nfrom core.audio.presets.base_preset import BasePreset\n\nclass MetallicRain(BasePreset):\n    def __init__(\n        self,\n        intensity=0.4,\n        duration=6.0,\n        grain_rate=7,\n        base_freq=432.0,\n        width=0.9,\n        fade_env=0.2,\n        hiss_mul_factor=0.1,\n        hiss_freq_ratio=1.2,\n        hiss_q=0.2,\n        sweep_start_ratio=1.8,\n        sweep_end_ratio=0.4,\n        sweep_dur=0.4,\n        drop_rand_min=0.1,\n        drop_rand_max=2.4,\n        amp_rand_min=0.3,\n        amp_rand_max=0.7,\n        rate_rand_min=0.1,\n        rate_rand_max=2.0,\n        grain_bp_ratio=1.1,\n        grain_bp_q=8.0,\n        mix_voices=2,\n        **kw\n    ):\n        kw.setdefault('stereo_w', width)\n        kw.setdefault('enable_reverb', True)\n        super().__init__(intensity=intensity, duration=duration, **kw)\n\n        # core parameters\n        self.grain_rate = grain_rate\n        self.base_freq = base_freq\n\n        # envelope / hiss\n        self.fade_env = fade_env\n        self.hiss_mul_factor = hiss_mul_factor\n        self.hiss_freq_ratio = hiss_freq_ratio\n        self.hiss_q = hiss_q\n\n        # sweep (body) parameters\n        self.sweep_start_ratio = sweep_start_ratio\n        self.sweep_end_ratio = sweep_end_ratio\n        self.sweep_dur = sweep_dur\n\n        # randomization ranges\n        self.drop_rand_min = drop_rand_min\n        self.drop_rand_max = drop_rand_max\n        self.amp_rand_min = amp_rand_min\n        self.amp_rand_max = amp_rand_max\n        self.rate_rand_min = rate_rand_min\n        self.rate_rand_max = rate_rand_max\n\n        # grain filter\n        self.grain_bp_ratio = grain_bp_ratio\n        self.grain_bp_q = grain_bp_q\n\n        # final mix\n        self.mix_voices = mix_voices\n\n    def _grain(self, freq, dur, amp):\n        \"\"\"Create one grain: band-passed sine burst, auto-out.\"\"\"\n        grain = ButBP(\n            Sine(freq=freq),\n            freq=freq * self.grain_bp_ratio,\n            q=self.grain_bp_q,\n            mul=amp\n        )\n        grain.out()\n        return grain\n\n    def _build(self):\n        # create shared envelope for hiss and grains\n        fade = self._env(self.fade_env)\n\n        # hiss floor\n        hiss = ButBP(\n            Noise(mul=fade * self.hiss_mul_factor),\n            freq=self.base_freq * self.hiss_freq_ratio,\n            q=self.hiss_q\n        )\n\n        # spawn grains in background\n        def rain_loop():\n            end_t = time.time() + (self.duration or 1e9)\n            while time.time() < end_t:\n                drop = self.base_freq * random.uniform(self.drop_rand_min, self.drop_rand_max)\n                glide = self._sweep(\n                    drop * self.sweep_start_ratio,\n                    drop * self.sweep_end_ratio,\n                    self.sweep_dur\n                )\n                dur = random.uniform(self.sweep_dur * 0.25, self.sweep_dur * 0.875)\n                amp = fade * random.uniform(self.amp_rand_min, self.amp_rand_max)\n                self._keep(self._grain(glide, dur, amp))\n                time.sleep(1 / (self.grain_rate * random.uniform(self.rate_rand_min, self.rate_rand_max)))\n\n        threading.Thread(target=rain_loop, daemon=True).start()\n\n        # mix to stereo\n        mix = Mix([hiss], voices=self.mix_voices)\n        self.chain = {\"fade\": fade, \"hiss\": hiss, \"mix\": mix}\n        return mix\n\n    def play(self):\n        mix = self._build()\n        mix.out()\n        return self.chain\n\nif __name__ == \"__main__\":\n    MetallicRain().play()\n"
        },
        {
            "file_path": "piano.py",
            "content": "#File:  audio/presets/piano.py \u00a9 2025 projectemergence. All rights reserved.\n# File: src/core/audio/presets/piano.py \u00a9 2025 projectemergence\n\nfrom pyo import Sine, Fader\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Piano(BasePreset):\n    def __init__(\n        self,\n        notes,\n        durations,\n        intensity=0.8,\n        fade_in=0.01,\n        fade_out=0.15,\n        fader_mul_factor=1.0,\n    ):\n        super().__init__(intensity, duration=None)\n        self.notes = notes\n        self.durations = durations\n        self.fade_in = fade_in\n        self.fade_out = fade_out\n        self.fader_mul_factor = fader_mul_factor\n\n    def _build(self):\n        seq = []\n        for note, dur in zip(self.notes, self.durations):\n            f = Fader(fadein=self.fade_in,\n                      fadeout=self.fade_out,\n                      dur=dur,\n                      mul=self.intensity * self.fader_mul_factor)\n            s = Sine(freq=note, mul=f)\n            seq.append((f, s))\n        return seq\n"
        },
        {
            "file_path": "preset_loading_animation.py",
            "content": "#File:  audio/presets/preset_loading_animation.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nFile: audio/presets/preset_loading_animation.py\n\u00a9 2025 projectemergence. All rights reserved.\n\nThis module provides enhanced audio effects synchronized with the loading animation visuals.\nAll audio creation for loading animations is centralized here.\nAdoptez une vision tourn\u00e9e vers l\u2019avenir!\n\"\"\"\n\nfrom pyo import Server, Sine, Fader, Noise, SigTo, Chorus, Freeverb, ButLP, ButBP, IRPulse\nimport time, threading, random, math\n\ndef create_loading_animation_audio(clt=None):\n    # Create (or reuse) the pyo Server and keep a reference to it.\n    server = clt._srv\n    server.start()\n    audio = {'server': server}  # <-- Save the server in the state.\n\n    # Drone Effect \u2013 using oneliners where possible.\n    audio['drone_fader'] = Fader(fadein=2.0, fadeout=2.0, dur=2, mul=0.0).play()\n    audio['drone_freq']  = SigTo(value=1000, time=0.5, init=100)\n    audio['drone_amp']   = SigTo(value=0.2, time=0.5, init=0.4)\n    drone = Sine(freq=audio['drone_freq'], mul=audio['drone_amp'] * audio['drone_fader'])\n    audio['drone'] = drone\n    audio['drone_filtered'] = ButLP(drone, audio['drone_freq']).out()\n\n    # Chorus Effect.\n    audio['chorus_fader'] = Fader(fadein=0.1, fadeout=1.0, dur=10, mul=0.0).play()\n    audio['chorus_noise'] = Noise(mul=audio['chorus_fader'])\n    audio['chorus'] = Chorus(audio['chorus_noise'], depth=1.0, feedback=0.6, bal=0.5).out()\n    \n    return audio\n\ndef update_drone(audio, settled_ratio, visual_metric=0.0):\n    audio['drone_freq'].value = 100 + settled_ratio * 600  # one-liner computation\n    audio['drone_amp'].value  = 0.2 + settled_ratio * 0.3\n    audio['drone_filtered'].freq = 250 + math.sqrt(visual_metric) * 500\n\ndef update_chorus(audio, folding_factor, visual_metric=0.0):\n    audio['chorus_fader'].mul = folding_factor * 0.4\n    audio['chorus'].depth = 1.0 + visual_metric * 0.5\n\n_comb_resonator = None\ndef _get_comb_resonator():\n    global _comb_resonator\n    if _comb_resonator is None:\n        # order=2048 sets the impulse-response length; drop unsupported 'size' & 'feedback'\n        _comb_resonator = IRPulse(input=Noise(mul=0), order=2048).out()\n    return _comb_resonator\n\ndef play_square_fall(audio, intensity=0.5, freq=200, harmonics=6):\n    \"\"\"\n    Overhauled square-fall:\n      \u2022 Additive burst of \u2018harmonics\u2019 partials (superposition in one-liner).\n      \u2022 Shared IRPulse comb filter for resonant ringing.\n    \"\"\"\n    # 1-liner additive burst envelope\n    env = Fader(fadein=0.01, fadeout=0.25, dur=0.25, mul=intensity).play()\n    burst = sum(Sine(freq=freq*(i+1), mul=env/(i+1)) for i in range(harmonics))\n    # feed burst into shared comb resonator input\n    comb = _get_comb_resonator()\n    comb.setInput(burst)\n    return burst\n\ndef play_final_flash(intensity=0.7, freq=4000):\n    flash_fader = Fader(fadein=0.01, fadeout=0.8, dur=0.15, mul=intensity).play()\n    flash_noise = Noise(mul=flash_fader)\n    flash_effect = ButLP(flash_noise, freq).out()\n    threading.Thread(target=lambda: (time.sleep(0.15), flash_effect.stop()), daemon=True).start()\n    return flash_effect\n\ndef play_final_flash_chords(intensity=0.7, total_duration=4.0):\n    chord1 = [59, 73, 98]   # E minor-like chord.\n    chord2 = [49, 65, 78]   # Dark chord.\n    chord_duration = 0.5  \n    num_chords = int(total_duration / chord_duration)\n\n    def play_chord(chord):\n        env = Fader(fadein=chord_duration/100, fadeout=chord_duration*0.5, dur=chord_duration, mul=intensity).play()\n        oscillators = []\n        for note in chord:\n            freq = 440.0 * (2 ** ((note - 69) / 12.0))\n            osc = Sine(freq=freq, mul=intensity)\n            osc_filtered = ButLP(osc, freq=2*freq)\n            osc_filtered.out()\n            oscillators.append(osc_filtered)\n        mix = sum(oscillators)\n        rev = Freeverb(mix, size=0.1, bal=0.3).out()\n        time.sleep(chord_duration)\n        for osc in oscillators: osc.stop()\n        rev.stop()\n\n    def chord_sequence():\n        for i in range(num_chords):\n            play_chord(chord1 if i % 2 == 0 else chord2)\n        print(\"Final flash gothic chords sequence completed.\")\n\n    threading.Thread(target=chord_sequence, daemon=True).start()\n\ndef play_dark_master_solo(intensity=0.8, total_duration=20.0):\n    chords = [\n        [59, 73, 98], [49, 65, 78], [55, 70, 90],\n        [52, 67, 83], [60, 72, 84], [57, 69, 87]\n    ]\n    chord_duration = 0.75\n    num_chords = int(total_duration / chord_duration)\n    melody_notes = [72, 74, 75, 77, 79, 80, 82]\n\n    def play_chord(chord):\n        env = Fader(fadein=chord_duration/100, fadeout=chord_duration*0.6, dur=chord_duration, mul=intensity).play()\n        oscillators = [ButLP(Sine(freq=440.0 * (2 ** ((note - 69) / 12.0)) * random.uniform(0.98, 1.02),\n                          mul=env/len(chord)), freq=2 * 440.0 * (2 ** ((note - 69) / 12.0)))\n                        for note in chord]\n        mix = sum(oscillators)\n        rev = Freeverb(mix, size=0.05, bal=0.35).out()\n        time.sleep(chord_duration)\n        for osc in oscillators: osc.stop()\n        rev.stop()\n\n    def play_melody():\n        end_time = time.time() + total_duration\n        while time.time() < end_time:\n            note = random.choice(melody_notes)\n            dur = random.choice([0.125, 0.25, 0.5])\n            env = Fader(fadein=dur/50, fadeout=dur*0.7, dur=dur, mul=intensity * 0.8).play()\n            osc = Sine(freq=440.0 * (2 ** ((note - 69) / 12.0)) * random.uniform(0.99, 1.01), mul=env).out()\n            time.sleep(dur * 0.9)\n            osc.stop()\n\n    threading.Thread(target=lambda: [play_chord(chords[i % len(chords)]) for i in range(num_chords)], daemon=True).start()\n    threading.Thread(target=play_melody, daemon=True).start()\n    print(\"Dark master solo performance started (non-blocking).\")\n\ndef play_metallic_rain_instrument(intensity=0.7, base_freq=600, visual_metric=0.5, fall_speed=1.0):\n    duration = max(0.1, 0.5 - fall_speed * 0.1)\n    env = Fader(fadein=duration/5, fadeout=duration*0.8, dur=duration, mul=intensity).play()\n    mod = Sine(freq=5, mul=base_freq * 0.02 * visual_metric, add=base_freq)\n    osc1 = Sine(freq=mod, mul=env)\n    osc2 = Sine(freq=base_freq * 1.5 * random.uniform(0.98, 1.02), mul=env*0.5)\n    mix = osc1 + osc2\n    ring_effect = ButBP(mix, freq=base_freq, q=8).out()\n    threading.Thread(target=lambda: (time.sleep(duration + 0.05), ring_effect.stop()), daemon=True).start()\n    return ring_effect\n\ndef stop_effects(audio, fade_time=10):\n    fade_drone = Fader(fadein=0.2, fadeout=fade_time/2, dur=fade_time, mul=0.5).play()\n    audio['drone_fader'].mul *= fade_drone\n    fade_chorus = Fader(fadein=0.5, fadeout=fade_time*2, dur=fade_time, mul=1).play()\n    audio['chorus_fader'].mul *= fade_chorus\n    def stop_all():\n        time.sleep(fade_time)\n        audio['drone'].stop(), audio['chorus_noise'].stop(), audio['chorus'].stop()\n        print(\"Enhanced loading animation audio effects stopped with fade out.\")\n    threading.Thread(target=stop_all, daemon=True).start()\n"
        },
        {
            "file_path": "reverse_impact.py",
            "content": "# File: src/core/audio/presets/reverse_impact.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nReverseImpact \u2013 swells that reverse-decay into impacts.\n\"\"\"\n\nfrom pyo import Noise, Fader, NewTable, TableRec, TableRead, ButBP, Disto\nfrom core.audio.presets.base_preset import BasePreset\n\nclass ReverseImpact(BasePreset):\n    def __init__(\n        self,\n        intensity=0.43,\n        duration=4.23,\n        env_dur=2.2,\n        bp_freq=800.0,\n        bp_q=5.0,\n        dist_drive=0.65,\n        dist_slope=0.39,\n        fade_in=0.07,\n        fade_out=0.41,\n        **kw\n    ):\n        super().__init__(intensity=0.43, duration=4.23, **kw)\n\n        # envelope recording length\n        self.env_dur = 2.2\n        self.fade_in = 0.07\n        self.fade_out = 0.41\n\n        # bandpass\n        self.bp_freq = 800.0\n        self.bp_q = 5.0\n\n        # distortion\n        self.dist_drive = 0.65\n        self.dist_slope = 0.39\n\n    def _build(self):\n        # create reversed envelope table\n        tbl = NewTable(length=self.env_dur)\n        env = Fader(fadein=self.env_dur, fadeout=0,\n                    dur=self.env_dur, mul=self.intensity).play()\n        # record noise burst\n        rec = TableRec(Noise(mul=env), table=tbl).play()\n\n        # read it *backwards*\n        reader = TableRead(\n            table=tbl,\n            freq=-tbl.getRate(),   # negative to reverse\n            init=1.0,              # start at the end (normalized)\n            loop=False,\n            mul=1.0\n        )\n\n        # then the rest of your chain\n        filtered  = ButBP(reader, freq=self.bp_freq, q=self.bp_q)\n        distorted = Disto(filtered,\n                          drive=self.dist_drive,\n                          slope=self.dist_slope,\n                          mul=1.0)\n\n        self.chain = {\n            \"env\": env,\n            \"rec\": rec,\n            \"reader\": reader,\n            \"filtered\": filtered,\n            \"distorted\": distorted\n        }\n        return distorted\n\n\n    def play(self):\n        out = self._build()\n        out.out()\n        return self.chain\n"
        },
        {
            "file_path": "snare.py",
            "content": "# File: src/core/audio/presets/snare.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nFile: audio/presets/snare.py\n\u00a9 2025 projectemergence. All rights reserved.\n\nDefines the Snare preset.\nSimulates a snare drum using a short burst of noise filtered with a narrow bandpass.\nAdoptez une vision tourn\u00e9e vers l\u2019avenir!\n\"\"\"\n\nfrom pyo import Noise, Fader, ButBP\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Snare(BasePreset):\n    def __init__(\n        self,\n        intensity=0.9,\n        duration=0.3,\n        center_freq=1800.0,\n        fade_in=0.005,\n        fade_out=0.2,\n        fader_mul_factor=1.0,\n        **kw\n    ):\n        # ensure stereo and reverb defaults\n        kw.setdefault('stereo_w', 0.0)\n        kw.setdefault('enable_reverb', False)\n        super().__init__(intensity=intensity, duration=duration, **kw)\n\n        # filter center frequency\n        self.center_freq = center_freq\n\n        # envelope settings\n        self.fade_in = fade_in\n        self.fade_out = fade_out\n        self.fader_mul_factor = fader_mul_factor\n\n        # storage for built objects\n        self.chain = {}\n\n    def _build(self):\n        # create the burst envelope\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        # noise source\n        noise = Noise(mul=fader)\n        # band-pass filter for snare character\n        snare = ButBP(noise, freq=self.center_freq)\n\n        self.chain = {\"fader\": fader, \"noise\": noise, \"snare\": snare}\n        return snare\n\n    def play(self):\n        snare = self._build()\n        # start envelope and output\n        self.chain[\"fader\"].play()\n        snare.out()\n        return self.chain\n\nif __name__ == \"__main__\":\n    Snare().play()\n"
        },
        {
            "file_path": "square_fall.py",
            "content": "# File: core/audio/presets/square_fall.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\nfrom pyo import Fader, Sine, IRPulse\nfrom core.audio.presets.base_preset import BasePreset\n\nclass SquareFallPreset(BasePreset):\n    \"\"\"Burst of harmonics into a comb filter (square-fall).\"\"\"\n    def __init__(self, *, intensity: float = 0.5, freq: float = 200, harmonics: int = 6):\n        super().__init__()\n        self.intensity = intensity\n        self.freq      = freq\n        self.harmonics = harmonics\n\n    def play(self):\n        env   = Fader(fadein=0.01, fadeout=0.25, dur=0.25, mul=self.intensity).play()\n        burst = sum(Sine(freq=self.freq * (i+1), mul=env / (i+1))\n                    for i in range(self.harmonics))\n        IRPulse(input=burst, order=2048).out()\n        return burst\n    def _build(self):\n        # envelope & additive burst\n        env = Fader(fadein=0.01, fadeout=0.25, dur=0.25, mul=self.intensity).play()\n        burst = sum(\n            Sine(freq=self.freq * (i + 1), mul=env / (i + 1))\n            for i in range(self.harmonics)\n        )\n        IRPulse(input=burst, order=2048).out()\n        return burst"
        },
        {
            "file_path": "trumpet.py",
            "content": "# File: src/core/audio/presets/trumpet.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nFile: audio/presets/trumpet.py\n\u00a9 2025 projectemergence. All rights reserved.\n\nDefines the Trumpet preset.\nEmulates a bright brass sound with a characteristically brassy vibrato and warm filtering.\nAdoptez une vision tourn\u00e9e vers l\u2019avenir!\n\"\"\"\n\nfrom pyo import Sine, Fader, Chorus, ButLP, SigTo\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Trumpet(BasePreset):\n    def __init__(\n        self,\n        intensity=0.8,\n        duration=1.5,\n        base_freq=440.0,\n        vibrato_rate=6.0,\n        vibrato_depth=10.0,\n        fade_in=0.05,\n        fade_out=0.7,\n        fader_mul_factor=1.0,\n        sigto_time_factor=1.0,\n        lp_freq=1000.0,\n        chorus_depth=1.0,\n        chorus_feedback=0.25,\n        chorus_bal=0.5,\n        **kw\n    ):\n        kw.setdefault('stereo_w', 0.0)\n        kw.setdefault('enable_reverb', False)\n        super().__init__(intensity=intensity, duration=duration, **kw)\n\n        # core tone parameters\n        self.base_freq = base_freq\n        self.vibrato_rate = vibrato_rate\n        self.vibrato_depth = vibrato_depth\n\n        # envelope settings\n        self.fade_in = fade_in\n        self.fade_out = fade_out\n        self.fader_mul_factor = fader_mul_factor\n\n        # SigTo (smooth freq) timing\n        self.sigto_time_factor = sigto_time_factor\n\n        # filtering\n        self.lp_freq = lp_freq\n\n        # chorus effect\n        self.chorus_depth = chorus_depth\n        self.chorus_feedback = chorus_feedback\n        self.chorus_bal = chorus_bal\n\n    def _build(self):\n        # amplitude envelope\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        # smooth base frequency holder\n        freq_mod = SigTo(\n            value=self.base_freq,\n            time=self.duration * self.sigto_time_factor\n        )\n        # vibrato oscillator\n        vibrato = Sine(freq=self.vibrato_rate, mul=self.vibrato_depth)\n        # combine base freq and vibrato\n        modulated_freq = freq_mod + vibrato\n        # carrier tone\n        tone = Sine(freq=modulated_freq, mul=fader)\n        # warm low-pass filter\n        filtered = ButLP(tone, freq=self.lp_freq)\n        # richness via chorus\n        chorus = Chorus(\n            filtered,\n            depth=self.chorus_depth,\n            feedback=self.chorus_feedback,\n            bal=self.chorus_bal\n        )\n\n        self.chain = {\n            \"fader\": fader,\n            \"freq_mod\": freq_mod,\n            \"vibrato\": vibrato,\n            \"tone\": tone,\n            \"filtered\": filtered,\n            \"chorus\": chorus\n        }\n        return chorus\n\n    def play(self):\n        out = self._build()\n        self.chain[\"fader\"].play()\n        out.out()\n        return self.chain\n\nif __name__ == \"__main__\":\n    Trumpet().play()\n"
        },
        {
            "file_path": "two_freq_drones.py",
            "content": "# File: src/core/audio/presets/two_freq_drones.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n# \u00a9 2025 projectemergence\n\n\"\"\"\nTwoFreqDrones \u2013 subtle, continuously-evolving dual-sine drone.\n\u2022 Always-on; no need to reschedule-loop.\n\u2022 Slow random drift on both oscillators via band-limited LFO.\n\u2022 Dual Faders give click-free start/stop and enable cross-fade\n  when the engine really has to restart the preset.\n\"\"\"\n\nfrom random import random\nfrom pyo import Sine, Fader, Sine as LFO\nfrom core.audio.presets.base_preset import BasePreset   # unchanged\n\nclass TwoFreqDrones(BasePreset):\n    def __init__(\n        self,\n        base_freq=65.4,\n        ratio=4/3,\n        drift_speed=0.04,\n        intensity=0.5,\n        fade=2.0,\n        drift_mul_ratio=0.015,\n        osc_amp_factor=0.5,\n        mix_voices=2,\n        **kw\n    ):\n        kw.setdefault('enable_reverb', True)\n        kw.setdefault('stereo_w', 0.3)\n        # duration=0 => infinite\n        super().__init__(intensity=intensity, duration=0, **kw)\n\n        # core parameters\n        self.base_freq = base_freq\n        self.ratio = ratio\n\n        # drift LFO\n        self.drift_speed = drift_speed\n        self.drift_mul_ratio = drift_mul_ratio\n\n        # cross-fade gate\n        self.fade = fade\n\n        # oscillator amplitude relative to gate\n        self.osc_amp_factor = osc_amp_factor\n\n        # mixing\n        self.mix_voices = mix_voices\n\n    def _drifting_osc(self, freq, amp):\n        \"\"\"Band-limited LFO to drift the oscillator frequency \u00b1drift_mul_ratio.\"\"\"\n        drift = LFO(\n            freq=self.drift_speed,\n            phase=random(),\n            mul=freq * self.drift_mul_ratio,\n            add=freq\n        )\n        return Sine(freq=drift, mul=amp)\n\n    def _build(self):\n        # gate fader for crossfade\n        gate = Fader(\n            fadein=self.fade,\n            fadeout=self.fade,\n            dur=self.duration,\n            mul=self.intensity\n        ).play()\n\n        # two drifting oscillators\n        osc_a = self._drifting_osc(self.base_freq, gate * self.osc_amp_factor)\n        osc_b = self._drifting_osc(self.base_freq * self.ratio, gate * self.osc_amp_factor)\n\n        # mix to stereo voices\n        mix = (osc_a + osc_b).mix(self.mix_voices)\n\n        # store chain\n        self.chain = {\"gate\": gate, \"osc_a\": osc_a, \"osc_b\": osc_b, \"mix\": mix}\n        return mix\n\n    def play(self):\n        out = self._build()\n        out.out()\n        return self.chain\n\nif __name__ == \"__main__\":\n    TwoFreqDrones().play()"
        },
        {
            "file_path": "violin.py",
            "content": "# File: src/core/audio/presets/violin.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nFile: audio/presets/violin.py\n\u00a9 2025 projectemergence. All rights reserved.\n\nDefines the Violin preset.\nSimulates a bowed string instrument using a sine oscillator with vibrato.\nAdoptez une vision tourn\u00e9e vers l\u2019avenir!\n\"\"\"\n\nfrom pyo import Sine, Fader\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Violin(BasePreset):\n    def __init__(\n        self,\n        intensity=0.5,\n        duration=3.0,\n        base_freq=4063.57,\n        vibrato_rate=5.0,\n        vibrato_depth=5.0,\n        fade_in=0.1,\n        fade_out=0.5,\n        fader_mul_factor=0.46,\n    ):\n        super().__init__(intensity, duration)\n        # core tone params\n        self.base_freq = 4063.57\n        self.vibrato_rate = 5.0\n        self.vibrato_depth = 5.0\n        # envelope params\n        self.fade_in = 0.1\n        self.fade_out = 0.5\n        self.fader_mul_factor = 0.46\n        # storage for chain\n        self.chain = {}\n\n    def _build(self):\n        # amplitude envelope\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        # vibrato LFO\n        vibrato = Sine(freq=self.vibrato_rate, mul=self.vibrato_depth)\n        # modulated carrier\n        modulated_freq = self.base_freq + vibrato\n        tone = Sine(freq=modulated_freq, mul=fader)\n        self.chain = {\"fader\": fader, \"vibrato\": vibrato, \"tone\": tone}\n        return self.chain\n\n    def play(self):\n        chain = self._build()\n        chain[\"fader\"].play()\n        chain[\"tone\"].out()\n        return chain\n\nif __name__ == \"__main__\":\n    Violin().play()"
        },
        {
            "file_path": "whale_calls.py",
            "content": "# File: src/core/audio/presets/whale_calls.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nFile: audio/presets/whale_calls.py\n\u00a9 2025 projectemergence. All rights reserved.\n\nDefines the WhaleCalls preset class.\nProvides a low\u2013frequency whale call preset.\n\nAdoptez une vision tourn\u00e9e vers l\u2019avenir!\n\"\"\"\n\nfrom pyo import Sine, Fader\nfrom core.audio.presets.base_preset import BasePreset\n\nclass WhaleCalls(BasePreset):\n    def __init__(\n        self,\n        intensity=0.4,\n        duration=4.0,\n        freq=110.0,\n        fade_in=1.0,\n        fade_out=1.0,\n        fader_mul_factor=1.0,\n        **kw\n    ):\n        kw.setdefault('stereo_w', 0.0)\n        kw.setdefault('enable_reverb', False)\n        super().__init__(intensity=intensity, duration=duration, **kw)\n        # core frequency\n        self.freq = freq\n        # envelope settings\n        self.fade_in = fade_in\n        self.fade_out = fade_out\n        self.fader_mul_factor = fader_mul_factor\n        # storage for chain\n        self.chain = {}\n\n    def _build(self):\n        # amplitude envelope\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        # carrier sine for whale call\n        sine = Sine(freq=self.freq, mul=fader)\n        self.chain = {\"fader\": fader, \"sine\": sine}\n        return sine\n\n    def play(self):\n        sine = self._build()\n        self.chain[\"fader\"].play()\n        sine.out()\n        return self.chain\n\nif __name__ == \"__main__\":\n    WhaleCalls().play()\n"
        },
        {
            "file_path": "wood_kick.py",
            "content": "# File: src/core/audio/presets/wood_kick.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n# \u00a9 2025 projectemergence. All rights reserved.\n\n\"\"\"\nWoodKick \u2013 a clean, wooden-character kick with minimal noise.\nTechnique enhancements:\n \u2022 body: sine sweep (45\u2192400 Hz) with high-pass DC removal\n \u2022 click: band-limited noise burst with high-pass cleanup\n \u2022 separate multi-stage envelopes for tight attack & body\n \u2022 gentle tanh saturation with pre-filter antialiasing\n\"\"\"\n\nfrom pyo import Sine, Noise, ButBP, ButHP, Biquad, Fader, SigTo, Tanh\nfrom core.audio.presets.base_preset import BasePreset\n\nclass WoodKick(BasePreset):\n    def __init__(\n        self,\n        intensity=0.3,\n        duration=0.36,\n        click_freq=1200.0,\n        hp_cut=200.0,\n        body_sweep_ratio=0.8,\n        body_mul_factor=1.9,\n        body_hpf_freq=20.0,\n        body_hpf_q=0.707,\n        body_hpf_type=2,\n        click_env_fadein=0.0005,\n        click_env_fadeout=0.05,\n        click_env_dur=0.05,\n        click_mul_factor=2.0,\n        click_bp_q=55.0,\n        sat_mul=1.5,\n        sat_hpf_freq=200.0,\n        sat_hpf_q=0.307,\n        sat_hpf_type=2,\n        **kw\n    ):\n        kw.setdefault('stereo_w', 0.0)\n        kw.setdefault('enable_reverb', False)\n        super().__init__(\n            intensity=2 * intensity,\n            duration=duration,\n            freq1=45.0,\n            freq2=400.0,\n            **kw\n        )\n        # click\n        self.click_freq = click_freq\n        self.hp_cut = hp_cut\n        # body\n        self.body_sweep_ratio = body_sweep_ratio\n        self.body_mul_factor = body_mul_factor\n        self.body_hpf_freq = body_hpf_freq\n        self.body_hpf_q = body_hpf_q\n        self.body_hpf_type = body_hpf_type\n        # click envelope\n        self.click_env_fadein = click_env_fadein\n        self.click_env_fadeout = click_env_fadeout\n        self.click_env_dur = click_env_dur\n        self.click_mul_factor = click_mul_factor\n        self.click_bp_q = click_bp_q\n        # saturation\n        self.sat_mul = sat_mul\n        self.sat_hpf_freq = sat_hpf_freq\n        self.sat_hpf_q = sat_hpf_q\n        self.sat_hpf_type = sat_hpf_type\n\n    def _body(self, env):\n        glide = self._sweep(\n            self.freq1,\n            self.freq2,\n            self.duration * self.body_sweep_ratio,\n            exp=False\n        )\n        osc = Sine(freq=glide, mul=env * self.body_mul_factor)\n        return Biquad(\n            osc,\n            freq=self.body_hpf_freq,\n            q=self.body_hpf_q,\n            type=self.body_hpf_type\n        )\n\n    def _click(self):\n        env = Fader(\n            fadein=self.click_env_fadein,\n            fadeout=self.click_env_fadeout,\n            dur=self.click_env_dur,\n            mul=self.click_mul_factor * self.intensity\n        ).play()\n        noise = Noise(mul=env)\n        bp = ButBP(noise, freq=self.click_freq, q=self.click_bp_q)\n        return ButHP(bp, freq=self.hp_cut)\n\n    def _build(self):\n        env = self._env(.005)\n        mix = self._body(env) + self._click()\n        sat = Tanh(mix * self.sat_mul)\n        out = Biquad(\n            sat,\n            freq=self.sat_hpf_freq,\n            q=self.sat_hpf_q,\n            type=self.sat_hpf_type\n        )\n        self.chain = {\"body_env\": env, \"mix\": mix, \"out\": out}\n        return out\n\n    def play(self):\n        out = self._build()\n        # start body envelope\n        self.chain[\"body_env\"].play()\n        out.out()\n        return self.chain\n\nif __name__ == \"__main__\":\n    WoodKick().play()\n"
        },
        {
            "file_path": "__init__.py",
            "content": "#File:  src/core/audio/__init__.py \u00a9 2025 projectemergence. All rights reserved.\n#File:  src/core/__init__.py \u00a9 2024 projectemergence. All rights reserved.\n# This file can be left empty, or you can use it to perform package-level initialization if needed.\n"
        }
    ]
}