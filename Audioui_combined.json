{
    "src_dir": "Audioui",
    "files": [
        {
            "file_path": "AudioUi.py",
            "content": "#File:  Audioui/AudioUi.py \u00a9 2025 projectemergence. All rights reserved.\n# File: audio_dev_ui.py\n# Tabbed, responsive UI for AudioEngineClient preset control (\u00a92025)\n\nimport os, json, time, math, traceback, inspect, importlib.util\nfrom pathlib import Path\nfrom tkinter import *\nfrom tkinter import ttk\nfrom core.audio.audio_engine_client import AudioEngineClient\n\nPRESET_DIR = Path(\"core/audio/presets\")\nBG = '#121212'; FG = '#FFA726'; BTN = '#FF5722'; TR = '#1E1E1E'\n\nclient = AudioEngineClient()\nclient.maestro.mute = False\n_state = {}\n\ndef discover_presets():\n    from core.audio.presets.base_preset import BasePreset\n    out = {}\n    for py in PRESET_DIR.glob(\"*.py\"):\n        if py.stem.startswith(\"_\") or py.stem in (\"base_preset\", \"__init__\"):\n            continue\n        try:\n            spec = importlib.util.spec_from_file_location(py.stem, py)\n            mod = importlib.util.module_from_spec(spec)\n            spec.loader.exec_module(mod)\n            cls = next(c for _, c in inspect.getmembers(mod, inspect.isclass) if issubclass(c, BasePreset) and c is not BasePreset)\n            sig = inspect.signature(cls.__init__)\n            fields = [(n, p.default if p.default is not inspect._empty else 0.0)\n                      for n, p in sig.parameters.items()\n                      if n != \"self\"]\n            out[py.stem] = (cls, fields)\n        except Exception:\n            print(f\"[ERROR] {py.name}:\"); traceback.print_exc()\n    return out\n\ndef build_slider(parent, preset, param, default):\n    def guess_range(n, v):\n        if isinstance(v, bool): return 0, 1, IntVar\n        if \"freq\" in n: return 20, 20000, DoubleVar\n        if any(k in n for k in (\"dur\", \"time\")): return 0, 10, DoubleVar\n        if \"pan\" in n: return -1, 1, DoubleVar\n        if isinstance(v, int): return 0, max(v*2, 8), IntVar\n        return 0.0, (v or 1.0) * 2, DoubleVar\n    lo, hi, VType = guess_range(param, default)\n    var = VType(value=default)\n    _state[preset][param] = default\n    frame = Frame(parent, bg=BG)\n    frame.pack(fill=X, pady=2, padx=4)\n    Label(frame, text=param, bg=BG, fg=FG, width=15).pack(side=LEFT)\n    scl = Scale(frame, from_=lo, to=hi, resolution=0.01, orient=HORIZONTAL,\n                bg=TR, fg=FG, troughcolor=TR, variable=var, length=200,\n                highlightthickness=0)\n    scl.pack(side=LEFT, fill=X, expand=True)\n    def update_value(v):\n        try: _state[preset][param] = float(v)\n        except: pass\n    scl.config(command=update_value)\n\ndef build_preset_tab(notebook, preset, fields):\n    tab = Frame(notebook, bg=BG)\n    canvas = Canvas(tab, bg=BG, highlightthickness=0)\n    scrollbar = Scrollbar(tab, orient=VERTICAL, command=canvas.yview)\n    canvas.configure(yscrollcommand=scrollbar.set)\n\n    scroll_frame = Frame(canvas, bg=BG)\n    scroll_frame.bind(\"<Configure>\", lambda e: canvas.configure(scrollregion=canvas.bbox(\"all\")))\n    canvas.create_window((0, 0), window=scroll_frame, anchor=\"nw\")\n\n    scrollbar.pack(side=RIGHT, fill=Y)\n    canvas.pack(side=LEFT, fill=BOTH, expand=True)\n\n    for param, default in fields:\n        build_slider(scroll_frame, preset, param, default)\n\n    notebook.add(tab, text=preset)\n\ndef play_selected(notebook, presets):\n    idx = notebook.index(notebook.select())\n    if idx < 0: return\n    preset = notebook.tab(idx, \"text\")\n    client.stop_all()\n    client.play_preset(preset, **_state[preset])\n\ndef stop_all():\n    client.stop_all()\n\nif __name__ == \"__main__\":\n    root = Tk()\n    root.title(\"Emergence Audio Dev UI\")\n    root.configure(bg=BG)\n    root.geometry(\"600x500\")\n\n    # Top control bar\n    topbar = Frame(root, bg=BG)\n    topbar.pack(side=TOP, fill=X)\n    Label(topbar, text=\"Emergence Audio Interface\", bg=BG, fg=FG, font=(\"Arial\", 12, \"bold\")).pack(side=LEFT, padx=10)\n    Button(topbar, text=\"\u25b6 Play\", bg=BTN, fg=\"white\", command=lambda: play_selected(notebook, presets)).pack(side=RIGHT, padx=5)\n    Button(topbar, text=\"\u25a0 Stop\", bg=BTN, fg=\"white\", command=stop_all).pack(side=RIGHT, padx=5)\n\n    # Tabbed notebook\n    notebook = ttk.Notebook(root)\n    notebook.pack(fill=BOTH, expand=True)\n    notebook.enable_traversal()\n\n    style = ttk.Style()\n    style.theme_use(\"default\")\n    style.configure(\"TNotebook\", background=BG)\n    style.configure(\"TNotebook.Tab\", background=TR, foreground=FG, lightcolor=BG, borderwidth=0)\n    style.map(\"TNotebook.Tab\", background=[(\"selected\", BTN)])\n\n    presets = discover_presets()\n    for name, (_, fields) in presets.items():\n        _state[name] = {}\n        build_preset_tab(notebook, name, fields)\n\n    root.mainloop()\n"
        },
        {
            "file_path": "core/audio/audio_engine_client.py",
            "content": "# File: src/core/audio/audio_engine_client.py  \u00a9 2025 projectemergence. All rights reserved.\n\nimport threading\nimport asyncio\nimport logging\nimport psutil, os, sys\nfrom core.audio.audio_engine_server import AudioEngine, log as server_log\nfrom core.audio.maestro.audio_maestro import Maestro\n\nclass AudioEngineClient:\n    \"\"\"\n    Asyncio\u2010based AudioEngineClient with its own event loop:\n\n      \u2022 Dedicated asyncio loop in a daemon thread  \n      \u2022 asyncio.Queue for commands and acknowledgements  \n      \u2022 Synchronous API: play_preset, play_block, schedule_preset, stop_preset, stop_all, list_scheduled, stop\n    \"\"\"\n    def __init__(self, *, debug: bool = True):\n        # \u2014 Logging setup \u2014\n        self.logger = logging.getLogger(__name__)\n        if debug:\n            logging.basicConfig(level=logging.DEBUG)\n\n        # \u2014 Start a private asyncio loop in a background thread \u2014\n        self.loop = asyncio.new_event_loop()\n        self._thread = threading.Thread(target=self._run_loop, daemon=True)\n        self._thread.start()\n\n        # \u2014 Finish async init on that loop \u2014\n        init_fut = asyncio.run_coroutine_threadsafe(self._init_async(), self.loop)\n        init_fut.result()  # block until ready\n\n    def _run_loop(self):\n        proc = psutil.Process()\n        try:\n            if sys.platform == \"win32\":\n                proc.nice(psutil.IDLE_PRIORITY_CLASS)\n            else:\n                os.nice(10)\n        except Exception:\n            print(\"\\n ################################################################################ \\nIssue setting thread priority \\n ################################################################################\\n\")\n            pass\n        \n        asyncio.set_event_loop(self.loop)\n        self.loop.run_forever()\n\n    async def _init_async(self):\n        # Queues for command/ack exchange\n        self.cmd_queue: asyncio.Queue[dict] = asyncio.Queue()\n        self.ack_queue: asyncio.Queue[dict] = asyncio.Queue()\n\n        # Track scheduled presets so we can cancel them later\n        self._sched: dict[str, asyncio.Future] = {}\n\n        # Instantiate the server engine on this loop\n        self.engine = AudioEngine(\n            cmd_queue=self.cmd_queue,\n            ack_queue=self.ack_queue\n        )\n        # Kick off the server\u2019s asyncio run() coroutine\n        self.loop.create_task(self.engine.run())\n\n        # Instantiate Maestro\n        self.maestro = Maestro(self)\n        self.maestro.mute = False\n        print(f\"[AudioClient]Mute is {self.maestro.mute}\")\n    def play_preset(self, preset: str, **params) -> None:\n        if self.maestro.mute==True:\n            self.stop_all()\n            return\n        \"\"\"\n        Enqueue a 'play_preset' command. Non\u2010blocking.\n        \"\"\"\n        asyncio.run_coroutine_threadsafe(\n            self.cmd_queue.put({\"cmd\": \"play_preset\", \"preset\": preset, \"params\": params}),\n            self.loop\n        )\n        self.logger.info(f\"\u25b6 play_preset {preset} {params}\")\n\n    def play_block(self, events: list[dict]) -> None:\n        if self.maestro.mute==True:\n            self.stop_all()\n            return\n        \"\"\"\n        Enqueue a list of events:\n        - each event is {\"time_offset\": float, \"preset\": str, \"params\": dict}\n        \"\"\"\n        asyncio.run_coroutine_threadsafe(\n         self.cmd_queue.put({\"cmd\": \"play_block\", \"events\": events}),\n         self.loop\n        )\n        self.logger.info(f\"\u25b6 play_block with {len(events)} events\")\n\n    def stop_preset(self, preset: str, *, fade: float = 1.0) -> None:\n        \"\"\"\n        Fade\u2010out a single preset and cancel its scheduler.\n        \"\"\"\n        asyncio.run_coroutine_threadsafe(\n            self.cmd_queue.put({\n                \"cmd\": \"play_preset\",\n                \"preset\": preset,\n                \"params\": {\"intensity\": 0, \"fade\": fade}\n            }),\n            self.loop\n        )\n        fut = self._sched.pop(preset, None)\n        if fut and not fut.cancelled():\n            fut.cancel()\n        self.logger.info(f\"\u2715 stopped preset {preset} (fade={fade}s)\")\n\n    def stop_all(self, *, fade: float = 1.0) -> None:\n        \"\"\"\n        Stop all playing & scheduled presets.\n        \"\"\"\n        for p in list(self._sched):\n            self.stop_preset(p, fade=fade)\n\n\n    def shutdown(self) -> None:\n        \"\"\"\n        Gracefully shut down the server loop and its thread.\n        \"\"\"\n        # 1) tell the engine to stop\n        asyncio.run_coroutine_threadsafe(self.cmd_queue.put({\"cmd\": \"stop\"}), self.loop).result()\n        # 2) stop the loop & join thread\n        self.loop.call_soon_threadsafe(self.loop.stop)\n        self._thread.join(timeout=2)\n        self.logger.info(\"shutdown complete\")\n\n    def stop(self) -> None:\n        \"\"\"\n        Alias for shutdown(), for legacy callers.\n        \"\"\"\n        self.shutdown()\n"
        },
        {
            "file_path": "core/audio/audio_engine_server.py",
            "content": "# File: src/core/audio/audio_engine_server.py  \u00a9 2025 projectemergence. All rights reserved.\n\nimport asyncio\nimport os\nimport time\nimport tempfile\nimport logging\nfrom typing import Any, Dict,Literal\nfrom core.audio.audio_presets_registry import registry\nfrom core.audio.presets.base_preset               import BasePreset\n\nimport pyttsx3\nfrom pyo import Server, SfPlayer\nimport pyo.lib._core as _pc\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\nTTSProp = Literal[\"voice\", \"rate\", \"volume\"]\n\n# \u2500\u2500\u2500 PortAudio race\u2010fix \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n_tmp = tempfile.mkdtemp(prefix=\"pyo_temp_\")\nos.environ.update({\"TMP\": _tmp, \"TEMP\": _tmp})\n_orig_pa = _pc.pa_get_default_devices_from_host\ndef _safe_pa(host):\n    try:\n        return _orig_pa(host)\n    except PermissionError as e:\n        if e.errno != os.errno.EACCES:\n            raise\n        time.sleep(0.2)\n        return _orig_pa(host)\n_pc.pa_get_default_devices_from_host = _safe_pa\n\ndef log(msg: str) -> None:\n    print(f\"[AudioEngineServer] {msg}\", flush=True)\n\nclass AudioEngine:\n    \"\"\"\n    Asyncio-based AudioEngineServer with:\n      \u2022 central PresetRegistry for hot-reload + introspection\n      \u2022 pyo-based TTS & block playback\n      \u2022 graceful shutdown on 'stop'\n    \"\"\"\n    def __init__(self,\n                 cmd_queue: asyncio.Queue,\n                 ack_queue: asyncio.Queue | None = None,\n                 *,\n                 default_voice_id=None,\n                 default_rate: int = 175,\n                 default_volume: float = 1.0,\n                 sample_rate: int = 44_100,\n                 buffersize: int = 1024):\n        self.cmd_queue      = cmd_queue\n        self.ack_queue      = ack_queue\n        self.shutdown_event = asyncio.Event()\n        self._voices        = []\n\n        logger.info(\"initialising AudioEngineServer\")\n\n        # \u2500\u2500\u2500 TTS engine \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        self._tts = pyttsx3.init()\n        self._tts.setProperty(\"rate\", default_rate)\n        self._tts.setProperty(\"volume\", default_volume)\n        if default_voice_id:\n            self._tts.setProperty(\"voice\", default_voice_id)\n        logger.info(\"pyttsx3 TTS ready\")\n\n        # \u2500\u2500\u2500 Pyo server \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        self.server = Server(sr=sample_rate, buffersize=buffersize, nchnls=2).boot().start()\n        logger.info(f\"pyo server up (sr={sample_rate}, bs={buffersize})\")\n\n        # \u2500\u2500\u2500 Central PresetRegistry \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        self.preset_map  = registry.preset_map\n        self.presets_sig = registry.presets_sig\n        logger.info(\"presets loaded \u2192 \" + \", \".join(sorted(self.preset_map)))\n        logger.debug(\"PRESET_MAP keys: %s\", list(self.preset_map.keys()))\n        logger.debug(\"PRESETS_SIG params: %s\",\n                     {k: list(sig.parameters.keys()) for k, sig in self.presets_sig.items()})\n        self.mute=False\n    async def run(self):\n        logger.info(\"server run loop started\")\n        while not self.shutdown_event.is_set():\n            cmd = await self.cmd_queue.get()\n            logger.debug(\"run loop received cmd: %s\", cmd)\n            try:\n                await self._handle(cmd)\n            finally:\n                self.cmd_queue.task_done()\n\n        # separate calls to avoid chaining None\n        self.server.stop()\n        self.server.shutdown()\n        logger.info(\"server shut down\")\n\n    async def _handle(self, cmd: Dict[str, Any]) -> None:\n        logger.debug(\"handling command: %s\", cmd)\n        match cmd.get(\"cmd\"):\n            case \"play_preset\":\n                await self._handle_play_preset(cmd)\n            case \"play_block\":\n                await self._handle_play_block(cmd)\n            case \"play_tts\":\n                self._handle_play_tts(cmd)\n            case \"set_tts\":\n                self._handle_set_tts(cmd)\n            case \"play_tts_direct\":\n                self._handle_play_tts_direct(cmd)\n            case \"stop\":\n                logger.debug(\"stop \u2192 shutting down\")\n                self.shutdown_event.set()\n            case other:\n                logger.warning(\"unhandled command: %r\", other)\n\n    async def _handle_play_preset(self, cmd: Dict[str, Any]) -> None:\n        name, params = cmd[\"preset\"], cmd.get(\"params\", {})\n        logger.debug(\"  play_preset \u2192 name=%s  params=%s\", name, params)\n\n        cls = self.preset_map.get(name)\n        if not cls:\n            logger.warning(\"  unknown preset '%s'\", name)\n            return\n\n        allowed = set(self.presets_sig[name].parameters) - {\"self\", \"args\", \"kwargs\"}\n        init_args = {k: v for k, v in params.items() if k in allowed}\n        logger.debug(\"  allowed args=%s  init_args=%s\", allowed, init_args)\n\n        t0 = time.perf_counter()\n        obj = cls(**init_args).play()\n        self._voices.append(obj)\n        dt = (time.perf_counter() - t0) * 1000\n        logger.info(\"\u25b6 %s %s (%.1f ms)\", name, init_args, dt)\n\n        if self.ack_queue:\n            await self.ack_queue.put({\"ok\": True, \"preset\": name, \"ts\": time.time()})\n\n    async def _handle_play_block(self, cmd: Dict[str, Any]) -> None:\n        events = cmd.get(\"events\", [])\n        logger.debug(\"  play_block \u2192 scheduling %d events\", len(events))\n        asyncio.create_task(self._process_block_events(events))\n\n    def _handle_play_tts(self, cmd: Dict[str, Any]) -> None:\n        text = cmd.get(\"text\", \"\")\n        logger.debug(\"  play_tts \u2192 text=%r\", text)\n        if not text:\n            return\n\n        fn = tempfile.mktemp(suffix=\".wav\")\n        self._tts.save_to_file(text, fn)\n        self._tts.runAndWait()\n        SfPlayer(fn, loop=False).out()\n\n    def _handle_play_tts_direct(self, cmd: Dict[str, Any]) -> None:\n        text = cmd.get(\"text\", \"\")\n        logger.debug(\"  play_tts_direct \u2192 text=%r\", text)\n        if not text:\n            return\n        self._tts.say(text)\n        #self._tts.runAndWait()\n\n    def _handle_set_tts(self, cmd: Dict[str, Any]) -> None:\n        \"\"\"\n        Update only those TTS properties that are provided and differ\n        from the current settings.\n        Supports:\n          - 'rate'   (int)\n          - 'volume' (float 0.0\u20131.0)\n          - 'voice'  (either an int index into voices[] or a voice-id string)\n        \"\"\"\n        # cache the voices list once (for index\u2192id translation)\n        voices_list = self._tts.getProperty('voices')\n\n        for prop in (\"rate\", \"volume\", \"voice\"):\n            # skip if not provided\n            if prop not in cmd:\n                continue\n\n            new_val = cmd[prop]\n            if new_val is None:\n                continue\n\n            if prop == \"voice\":\n                # allow passing an index or a direct id\n                if isinstance(new_val, int):\n                    try:\n                        new_id = voices_list[new_val].id\n                    except (IndexError, AttributeError):\n                        logger.warning(\"Invalid voice index: %r\", new_val)\n                        continue\n                else:\n                    new_id = new_val\n\n                current = self._tts.getProperty(\"voice\")\n                if new_id != current:\n                    self._tts.setProperty(\"voice\", new_id)\n                    logger.info(\"TTS property voice set to %s\", new_id)\n\n            else:\n                # 'rate' or 'volume'\n                current = self._tts.getProperty(prop)\n                if new_val != current:\n                    self._tts.setProperty(prop, new_val)\n                    logger.info(\"TTS property %s set to %s\", prop, new_val)\n\n\n    async def _process_block_events(self, events: list[dict]):\n        logger.debug(\"process_block_events start: %s\", events)\n        loop  = asyncio.get_running_loop()\n        start = loop.time()\n\n        for ev in sorted(events, key=lambda e: e[\"time_offset\"]):\n            logger.debug(\"  next event: %s\", ev)\n            await asyncio.sleep(max(0, (start + ev[\"time_offset\"]) - loop.time()))\n\n            name, params = ev[\"preset\"], ev.get(\"params\", {})\n            logger.debug(\"    firing preset '%s'  raw params=%s\", name, params)\n\n            cls = self.preset_map.get(name)\n            if not cls:\n                logger.warning(\"    [play_block] unknown preset '%s'\", name)\n                continue\n\n            allowed = set(self.presets_sig[name].parameters) - {\"self\", \"args\", \"kwargs\"}\n            pr_args = {k: v for k, v in params.items() if k in allowed}\n            meta    = {k: v for k, v in params.items() if k not in allowed}\n            logger.debug(\"    split \u2192 pr_args=%s  meta=%s\", pr_args, meta)\n\n            chain = cls(**pr_args).play()\n            self._voices.append(chain)\n            logger.info(\"\u25b6 [play_block] %s %s @ %.2fs\", name, pr_args, ev[\"time_offset\"])\n\n            if gain := meta.get(\"gain_db\"):\n                logger.debug(\"      applying gain_db=%.2f\", gain)\n                for node in getattr(chain, \"values\", lambda: [])():\n                    try: node.mul *= 10 ** (gain/20)\n                    except: pass\n\n            if meta.get(\"enable_reverb\"):\n                logger.debug(\"      applying reverb\")\n                from pyo import Freeverb\n                for sig in getattr(chain, \"values\", lambda: [])():\n                    try: Freeverb(sig, size=0.8, bal=0.35).out()\n                    except: pass\n\n            if meta.get(\"enable_chorus\"):\n                logger.debug(\"      applying chorus\")\n                from pyo import Chorus\n                for sig in getattr(chain, \"values\", lambda: [])():\n                    try: Chorus(sig, depth=0.5, feedback=0.25, bal=0.5).out()\n                    except: pass\n"
        },
        {
            "file_path": "core/audio/audio_presets_registry.py",
            "content": "# File: src/core/audio/presets/audio_presets_registry.py  \u00a9 2025 projectemergence. All rights reserved.\n\nimport pkgutil\nimport importlib\nimport inspect\nimport threading\nimport logging\nimport time\n\nfrom core.audio.presets.base_preset import BasePreset\nimport core.audio.presets as presets_pkg\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n\nclass PresetRegistry:\n    \"\"\"\n    Discovers and introspects all presets in core.audio.presets.\n    No background polling\u2014reload is entirely on-demand or manual.\n    \"\"\"\n    def __init__(self):\n        self.preset_map:  dict[str, type[BasePreset]]   = {}\n        self.presets_sig: dict[str, inspect.Signature] = {}\n        self.presets_meta: dict[str, dict[str, object]] = {}\n        self._lock = threading.Lock()\n\n        logger.debug(\"Initializing PresetRegistry\")\n        # initial load\n        self._load_all_presets()\n\n    def reload(self):\n        \"\"\"\n        Manually trigger a full reload of all presets.\n        Can be called at runtime from any external code.\n        \"\"\"\n        logger.info(\"Manual reload of presets requested\")\n        self._load_all_presets()\n\n    def _load_all_presets(self):\n        \"\"\"\n        (Re)scan the presets package, import each module,\n        pick a preset class, introspect its constructor,\n        and update the registry maps. Thread-safe.\n        \"\"\"\n        logger.debug(\"Loading presets from %s\", presets_pkg.__path__)\n        new_map, new_sigs, new_meta = {}, {}, {}\n\n        for finder, name, ispkg in pkgutil.iter_modules(presets_pkg.__path__):\n            if name.startswith(\"_\"):\n                logger.debug(\"  skipping internal module '%s'\", name)\n                continue\n\n            mod_name = f\"{presets_pkg.__name__}.{name}\"\n            try:\n                logger.debug(\"  importing %s\", mod_name)\n                mod = importlib.reload(importlib.import_module(mod_name))\n            except Exception as e:\n                logger.exception(\"  failed to import %s: %s\", mod_name, e)\n                continue\n\n            # 1) Prefer an explicit BasePreset subclass\n            preset_cls = next(\n                (c for _, c in inspect.getmembers(mod, inspect.isclass)\n                 if issubclass(c, BasePreset) and c is not BasePreset),\n                None\n            )\n\n            # 2) Fallback: first class defined in this module\n            if not preset_cls:\n                local = [\n                    c for _, c in inspect.getmembers(mod, inspect.isclass)\n                    if c.__module__ == mod_name\n                ]\n                if local:\n                    preset_cls = local[0]\n                    logger.debug(\"    fallback to local class %s in %s\", preset_cls.__name__, name)\n\n            if not preset_cls:\n                logger.debug(\"    no class found for preset '%s'\", name)\n                continue\n\n            # introspect constructor\n            sig = inspect.signature(preset_cls.__init__)\n            meta = {\n                p.name: p.default\n                for p in sig.parameters.values()\n                if p.name != \"self\" and p.default is not inspect._empty\n            }\n\n            new_map[name]   = preset_cls\n            new_sigs[name]  = sig\n            new_meta[name]  = meta\n\n            logger.info(\"Registered preset '%s' \u2192 %s(); params=%s\",\n                        name, preset_cls.__name__, list(meta.keys()))\n\n        # swap in the new maps under lock\n        with self._lock:\n            self.preset_map.clear()\n            self.preset_map.update(new_map)\n            self.presets_sig.clear()\n            self.presets_sig.update(new_sigs)\n            self.presets_meta.clear()\n            self.presets_meta.update(new_meta)\n\n        logger.debug(\"PresetRegistry now contains: %s\", list(self.preset_map.keys()))\n\n    # no background thread or polling\u2014_watch_loop is disabled\n    def _watch_loop(self):\n        return\n\n# singleton instance\nregistry = PresetRegistry()\n"
        },
        {
            "file_path": "core/audio/tts_engine.py",
            "content": "# File: src/core/audio/tts_engine.py  \u00a9 2025 projectemergence. All rights reserved.\n\nimport asyncio\nfrom typing import Optional\n\nimport numpy as np\nfrom scipy.signal import resample\nimport sounddevice as sd\n\nclass TTSEngine:\n    \"\"\"\n    Async TTS engine using Coqui VITS:\n      \u2022 Lazy\u2010loads the model on first use\n      \u2022 Offloads synthesis & playback to a ThreadPoolExecutor\n    \"\"\"\n    def __init__(self,\n                 model_name: str = \"tts_models/en/vctk/vits\",\n                 speaker: str = \"p291\",\n                 rate: float = 1.0,\n                 pitch_shift: float = 0.0):\n        self._model_name = model_name\n        self._speaker = speaker\n        self._rate = rate\n        self._pitch_shift = pitch_shift\n        self._tts: Optional[\"TTS\"] = None\n\n    async def _ensure_loaded(self):\n        if self._tts is None:\n            from TTS.api import TTS\n            loop = asyncio.get_running_loop()\n            self._tts = await loop.run_in_executor(\n                None, lambda: TTS(self._model_name, progress_bar=False, gpu=False)\n            )\n\n    async def speak(self, text: str) -> None:\n        \"\"\"\n        Asynchronously synthesize and play `text`.\n        \"\"\"\n        await self._ensure_loaded()\n        loop = asyncio.get_running_loop()\n\n        # 1) synthesize off\u2010thread\n        audio = await loop.run_in_executor(\n            None,\n            lambda: self._tts.tts(text=text, speaker=self._speaker, return_type=\"numpy\")\n        )\n\n        # 2) optional rate change\n        if self._rate != 1.0:\n            audio = resample(audio, int(len(audio) / self._rate))\n\n        # 3) play off\u2010thread\n        def _play():\n            sd.play(audio, samplerate=22050)\n            sd.wait()\n\n        await loop.run_in_executor(None, _play)\n"
        },
        {
            "file_path": "core/audio/__init__.py",
            "content": "#File:  src/core/audio/__init__.py \u00a9 2025 projectemergence. All rights reserved.\n#File:  src/core/__init__.py \u00a9 2024 projectemergence. All rights reserved.\n# This file can be left empty, or you can use it to perform package-level initialization if needed.\n"
        },
        {
            "file_path": "core/audio/maestro/arrangement_engine.py",
            "content": "# File: src/core/audio/maestro/arrangement_engine.py  \u00a9 2025 projectemergence. All rights reserved.\n\nimport random\nfrom typing import Dict, List, Any\nfrom core.audio.maestro.harmonic     import HarmonicAnalyser\nfrom core.audio.maestro.progression  import ProgressionSynth\nfrom core.audio.maestro.orchestrator import Orchestrator\nfrom core.audio.maestro.automix      import AutoMixer\n\nclass ArrangementEngine:\n    def __init__(self, client, maestro=None):\n        self.client = client\n        self.maestro=maestro\n        self.ha     = HarmonicAnalyser()\n        self.ps     = ProgressionSynth()\n        self.orc    = Orchestrator()\n        self.mix    = AutoMixer()\n\n    def prepare_block(self, beats: float = 4.0) -> Dict[str, Dict[str, Any]]:\n        if self.maestro.mute==True:\n            return\n        \"\"\"\n        1) Pull a full block of melody events from the Compositor.\n        2) Analyze melody \u2192 chord progression \u2192 orchestration.\n        3) Inject the raw melody as its own part.\n        4) Auto-mix & return the per-part configs.\n        \"\"\"\n        # 1) Gather raw block events\n        raw = self.client.maestro.compositor.next_block_events(beats)\n\n        # a) flatten melody for analysis\n        melody = [(f, d) for ev in raw for f, d, _ in zip(ev['notes'], ev['durations'], ev['intensity'])]\n        analysis = self.ha.describe(melody)\n\n        # b) chord progression\n        chords = self.ps.next(analysis, beats)\n        chord_dur = beats / max(len(chords), 1)\n        chord_durs = [chord_dur] * len(chords)\n\n        # c) orchestration\n        parts = self.orc.voice(chords, chord_durs)\n\n        # 2) inject raw melody\n        parts['melody'] = {\n            'notes':     [f for ev in raw for f in ev['notes']],\n            'durations': [d for ev in raw for d in ev['durations']],\n            'intensity': [i for ev in raw for i in ev['intensity']],\n        }\n\n        # 3) batch auto-mix\n        return self.mix.autoset(parts)\n"
        },
        {
            "file_path": "core/audio/maestro/audio_maestro.py",
            "content": "# File: src/core/audio/maestro/audio_maestro.py \u00a9 2025 projectemergence. All rights reserved.\n\nimport asyncio\nimport logging\nimport os\nimport pkgutil\nimport random\nimport time\n\nfrom core.audio.audio_presets_registry import registry\nfrom core.audio.maestro.maestro_compositor import Compositor\nfrom core.audio.maestro.arrangement_engine import ArrangementEngine\n\nclass Maestro:\n    \"\"\"\n    Async Generative Music Maestro using a single PresetRegistry.\n    \"\"\"\n    def __init__(self, client):\n        self.client = client\n        self.logger = logging.getLogger(__name__)\n        self.zones, self.tasks, self.sfx_events = {}, {}, []\n        self.mute=False\n        print(f\"Mute is {self.mute}\")\n        # LFO state\n        self.tempo, self.energy = 120.0, 0.7\n        self._last_time, self._phase = time.time(), 0.02\n\n        # Central registry\n        self.presets_sig  = registry.presets_sig\n        self.presets_meta = registry.presets_meta\n        self.all_presets  = list(registry.preset_map)\n        self.logger.info(f\"All presets discovered: {self.all_presets}\")\n\n        # Compositor & arranger\n        base = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\", \"melodies\"))\n\n        #self.compositor = Compositor(base,maestro=self)\n        #self.arranger    = ArrangementEngine(self.client,maestro=self)\n\n    def queue_sfx(self, name: str, *, delay: float = 0.0, params: dict = None):\n        if self.mute==True:\n            if old := self.tasks.pop(zone, None): old.cancel()\n            self.client.stop_all()\n            return\n        self.sfx_events.append({\n            \"time_offset\": delay,\n            \"preset\":      name,\n            \"params\":      params or {}\n        })\n\n    def enter_zone(self, zone: str, presets: set[str]):\n        if self.mute==True:\n            if old := self.tasks.pop(zone, None): old.cancel()\n            self.client.stop_all()\n            return\n        if old := self.tasks.pop(zone, None): old.cancel()\n        self.zones[zone] = presets\n        self.tasks[zone] = asyncio.run_coroutine_threadsafe(self._zone_block_loop(zone), self.client.loop)\n\n    set_zone = enter_zone\n\n    def leave_zone(self, zone: str):\n        if fut := self.tasks.pop(zone, None): fut.cancel()\n        self.zones.pop(zone, None)\n\n    async def _zone_block_loop(self, zone: str):\n        if self.mute==True:\n            if old := self.tasks.pop(zone, None): old.cancel()\n            self.client.stop_all()\n            return\n        beats, first = 8.0, True\n        while True:\n            try:\n                if first:\n                    mel = random.choice(list(self.compositor.melodies.keys()))\n                    self.compositor.start(mel)\n                    first = False\n                    self.logger.info(f\"[{zone}] starting melody '{mel}'\")\n\n                self._update_tempo(); self._update_energy()\n                raw      = self.compositor.next_block_events(beats)\n                parts_fx = self.arranger.prepare_block(beats=beats)\n\n                # Remap each part to a random preset\n                remapped = {random.choice(self.all_presets): cfg for cfg in parts_fx.values()}\n                self.logger.debug(f\"[{zone}] remapped parts\u2192presets: {list(remapped)}\")\n\n                events = []\n                # raw melody under 'lead'\n                for ev in raw:\n                    events.append({\n                        \"time_offset\": ev[\"time\"] * (60.0/self.tempo),\n                        \"preset\":      \"lead\",\n                        \"params\":      {\n                            \"notes\":     ev[\"notes\"],\n                            \"durations\": ev[\"durations\"],\n                            \"intensity\": ev[\"intensity\"]\n                        }\n                    })\n                # orchestration\n                for p, cfg in remapped.items():\n                    events.append({\"time_offset\": 0.0, \"preset\": p, \"params\": cfg})\n                # queued SFX\n                events.extend(self.sfx_events)\n                self.sfx_events.clear()\n\n                events.sort(key=lambda e: e[\"time_offset\"])\n                self.client.play_block(events)\n                self.logger.debug(f\"[{zone}] play_block \u2192 {len(events)} events\")\n\n                await asyncio.sleep(beats * (60.0/self.tempo))\n\n            except asyncio.CancelledError:\n                break\n            except Exception as e:\n                self.logger.warning(f\"Error in zone '{zone}': {e}\")\n\n    def _update_tempo(self):\n        if self.mute==True:\n            if old := self.tasks.pop(zone, None): old.cancel()\n            self.client.stop_all()\n            return\n        step = self.tempo * random.uniform(-0.07, 0.07)\n        self.tempo = max(60.0, min(240.0, self.tempo + random.uniform(-step, step)))\n\n    def _update_energy(self):\n        if self.mute==True:\n            if old := self.tasks.pop(zone, None): old.cancel()\n            self.client.stop_all()\n            return\n        now, dt = time.time(), time.time() - self._last_time\n        beat_time = 60.0/self.tempo\n        self._phase   = (self._phase + dt/(32*beat_time)) % 1.0\n        self.energy   = 0.7 + 0.3 * (__import__(\"math\").sin(2*__import__(\"math\").pi*self._phase))\n        self._last_time = now\n"
        },
        {
            "file_path": "core/audio/maestro/automix.py",
            "content": "# File: src/core/audio/maestro/automix.py  \u00a9 2025 projectemergence. All rights reserved.\n\nimport pyloudnorm as pyln\nimport numpy as np\nfrom pydub import AudioSegment\nfrom typing import Dict, Any\n\nclass AutoMixer:\n    \"\"\"\n    Batch FFT & loudness EQ for entire blocks:\n      \u2022 One integrated loudness measurement per part\n      \u2022 Frequency\u2010bin cache by sample\u2010count\n      \u2022 Heuristic reverb/chorus flags\n    \"\"\"\n    def __init__(self, target_lufs: float = -14.0, sr: int = 48000):\n        self.meter = pyln.Meter(sr)\n        self.target = target_lufs\n        self.sr = sr\n        # cache rfftfreq arrays by length\n        self._freq_cache: Dict[int, np.ndarray] = {}\n\n    def autoset(self,\n                parts: Dict[str, Dict[str, Any]],\n                target_lufs: float | None = None\n               ) -> Dict[str, Dict[str, Any]]:\n        tgt = target_lufs if target_lufs is not None else self.target\n\n        for name, cfg in parts.items():\n            # render a quick sine\u2010stub\n            seg = self._sine_stub(cfg['notes'], cfg['durations'], sr=self.sr)\n            samples = np.array(seg.get_array_of_samples(), dtype=float)\n\n            N = len(samples)\n            if N not in self._freq_cache:\n                # cache once\n                self._freq_cache[N] = np.fft.rfftfreq(N, 1/self.sr)\n            freqs = self._freq_cache[N]\n\n            # compute magnitude spectrum (if you need it for advanced EQ later)\n            _ = np.abs(np.fft.rfft(samples))\n\n            # loudness\u2010based gain_dB\n            loud = self.meter.integrated_loudness(samples)\n            parts[name]['gain_db'] = 3 #tgt - loud\n\n            # simple FX heuristics\n            parts[name]['enable_reverb']  = np.mean(cfg['notes']) > 60\n            parts[name]['enable_chorus']  = len(cfg['notes']) > 6\n\n        return parts\n\n    @staticmethod\n    def _sine_stub(notes, durs, sr=48000) -> AudioSegment:\n        \"\"\"\n        Quick AudioSegment of concatenated sine\u2010tones for level analysis.\n        \"\"\"\n        samples = []\n        for n, d in zip(notes, durs):\n            # midi-to-frequency fallback if needed\n            freq = n if isinstance(n, float) else 440.0\n            N = int(sr * d)\n            t = np.linspace(0, d, N, False)\n            samples.append(np.sin(2 * np.pi * freq * t))\n        arr = np.concatenate(samples)\n        pcm = (arr * 32767).astype(np.int16).tobytes()\n        return AudioSegment(pcm, frame_rate=sr, sample_width=2, channels=1)\n"
        },
        {
            "file_path": "core/audio/maestro/harmonic.py",
            "content": "# File: src/core/audio/maestro/harmonic.py  \u00a9 2025 projectemergence. All rights reserved.\n\nimport math\nfrom typing import List, Tuple, Dict\nimport functools\n\nimport numpy as np\nfrom music21 import note, stream, analysis\n\n# build major/minor triad templates in pitch\u2010class space\n_NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B']\n_CHORD_TEMPLATES: Dict[str, List[int]] = {\n    **{name: [i, (i+4)%12, (i+7)%12] for i,name in enumerate(_NOTE_NAMES)},      # major\n    **{name+'m': [i, (i+3)%12, (i+7)%12] for i,name in enumerate(_NOTE_NAMES)},  # minor\n}\n\nclass HarmonicAnalyser:\n    \"\"\"\n    Real\u2010time key, chord & function estimation with caching:\n      \u2022 @lru_cache on describe calls (cached by tuple(melody))\n      \u2022 Input melody converted to hashable tuple internally\n    \"\"\"\n    def __init__(self):\n        # wrap the uncached implementation in an LRU cache\n        self._describe_cached = functools.lru_cache(maxsize=128)(self._describe_uncached)\n\n    def describe(self, melody: List[Tuple[float, float]]) -> Dict[str, List]:\n        \"\"\"\n        Memoized wrapper. Converts `melody` list to a tuple for caching.\n        \"\"\"\n        return self._describe_cached(tuple(melody))\n\n    def _describe_uncached(\n        self,\n        melody: Tuple[Tuple[float, float], ...]\n    ) -> Dict[str, List]:\n        \"\"\"\n        Original implementation, renamed to _describe_uncached.\n        \"\"\"\n        # 1) Key estimation\n        s = stream.Stream()\n        offset = 0.0\n        for freq, dur in melody:\n            n = note.Note()\n            n.pitch.frequency = freq\n            n.offset = offset\n            n.quarterLength = dur\n            s.insert(n)\n            offset += dur\n        key_obj = s.analyze(\"Krumhansl\")\n        key = f\"{key_obj.tonic.name} {key_obj.mode}\"\n\n        # 2) collect events as (time, pitch_class)\n        events = []\n        t = 0.0\n        for freq, dur in melody:\n            midi = int(round(69 + 12*math.log2(freq/440.0)))\n            pc = midi % 12\n            events.append((t, pc))\n            t += dur\n\n        total_beats = math.ceil(offset)\n        chords, durations = [], []\n        tonic_pc = _NOTE_NAMES.index(key_obj.tonic.name)\n\n        # 3) for each beat\u2010window pick best triad\n        for b in range(total_beats):\n            window = [pc for time, pc in events if b <= time < b+1]\n            if not window:\n                symbol = key_obj.tonic.name + (\"\" if key_obj.mode==\"major\" else \"m\")\n            else:\n                hist = np.zeros(12, int)\n                for pc in window:\n                    hist[pc] += 1\n                best_score, symbol = -1, key_obj.tonic.name\n                for sym, template in _CHORD_TEMPLATES.items():\n                    score = sum(hist[pc] for pc in template)\n                    if score > best_score:\n                        best_score, symbol = score, sym\n            chords.append(symbol)\n            durations.append(1.0)\n\n        # 4) map each chord \u2192 function (0=T,1=S,2=D)\n        functions = []\n        for sym in chords:\n            root = sym.rstrip('m')\n            root_pc = _NOTE_NAMES.index(root) if root in _NOTE_NAMES else tonic_pc\n            interval = (root_pc - tonic_pc) % 12\n            if interval in (7, 11):\n                functions.append(2)\n            elif interval in (2, 5):\n                functions.append(1)\n            else:\n                functions.append(0)\n\n        return {\n            \"key\":       key,\n            \"chords\":    chords,\n            \"functions\": functions,\n            \"durations\": durations\n        }\n"
        },
        {
            "file_path": "core/audio/maestro/maestro_compositor.py",
            "content": "# File: src/core/audio/maestro/maestro_compositor.py  \u00a9 2025 projectemergence. All rights reserved.\n\nimport os\nimport re\nimport json\nimport random\nfrom typing import List, Tuple, Dict, Optional, Any\n\n# A single note event: (frequency in Hz, duration in beats, intensity 0\u20131)\nNoteEvent = Tuple[float, float, float]\n\nclass Compositor:\n    \"\"\"\n    \u2022 Loads JSON5\u2010style melody files (comments allowed)\n    \u2022 Captures all metadata (title, structure, remix params, etc.)\n    \u2022 Falls back to legacy \"notes\" arrays when \"hands\" is absent\n    \u2022 Exposes get_full_sequence(), next_event(), and next_block_events()\n    \"\"\"\n    def __init__(self, repo_path: str, default_intensity: float = 0.8,maestro=None):\n        self.repo_path         = repo_path\n        self.default_intensity = default_intensity\n        self.maestro=maestro\n        # name \u2192 metadata dict (everything except 'hands'/'notes')\n        self.metadata:  Dict[str, Dict[str, Any]]          = {}\n        # name \u2192 list of hands \u2192 list of NoteEvent\n        self.melodies:  Dict[str, List[List[NoteEvent]]]   = {}\n        # name \u2192 tempo (BPM)\n        self.tempos:    Dict[str, float]                   = {}\n        # name \u2192 (beats_per_bar, beat_unit)\n        self.meters:    Dict[str, Tuple[int,int]]          = {}\n\n        # playback state\n        self.current_hands:   List[List[NoteEvent]] = []\n        self.idxs:            List[int]             = []\n        self.current_melody:  Optional[str]         = None\n\n        print(f\"[Compositor] Scanning melodies in {self.repo_path}\")\n        self._load_repo()\n\n    def _load_repo(self):\n        if self.maestro.mute==True:\n            return\n        def strip_comments(text: str) -> str:\n            without_block = re.sub(r'/\\*.*?\\*/', '', text, flags=re.DOTALL)\n            without_line  = re.sub(r'//.*', '', without_block)\n            return without_line\n\n        for fn in sorted(os.listdir(self.repo_path)):\n            if not fn.lower().endswith(\".json\"):\n                continue\n            path = os.path.join(self.repo_path, fn)\n            name = fn[:-5]\n            try:\n                raw  = open(path, encoding=\"utf-8\").read()\n                data = json.loads(strip_comments(raw))\n            except Exception as e:\n                print(f\"[Compositor] Failed to parse {fn}: {e}\")\n                continue\n\n            md = {k: v for k, v in data.items() if k not in (\"hands\", \"notes\")}\n            self.metadata[name] = md\n\n            if \"tempo\" in data:\n                self.tempos[name] = float(data[\"tempo\"])\n                print(f\"[Compositor] '{name}': tempo={data['tempo']} BPM\")\n            if \"time_signature\" in data:\n                tsig = data[\"time_signature\"]\n                try:\n                    num, den = map(int, tsig.split(\"/\"))\n                    self.meters[name] = (num, den)\n                    print(f\"[Compositor] '{name}': time_signature={tsig}\")\n                except:\n                    print(f\"[Compositor] '{name}': invalid time_signature '{tsig}'\")\n\n            hands_raw = data.get(\"hands\") or ([data[\"notes\"]] if \"notes\" in data else None)\n            hands_evs: List[List[NoteEvent]] = []\n            if isinstance(hands_raw, list):\n                for hl in hands_raw:\n                    if not isinstance(hl, list):\n                        continue\n                    evs: List[NoteEvent] = []\n                    for o in hl:\n                        try:\n                            f = float(o[\"frequency\"])\n                            d = float(o.get(\"duration_beats\", o.get(\"duration\", 1.0)))\n                            i = float(o.get(\"intensity\", self.default_intensity))\n                            evs.append((f, d, i))\n                        except:\n                            continue\n                    if evs:\n                        hands_evs.append(evs)\n            if hands_evs:\n                self.melodies[name] = hands_evs\n                print(f\"[Compositor] Registered '{name}' with {len(hands_evs)} hand(s)\")\n            else:\n                print(f\"[Compositor] No valid events in '{name}', skipping\")\n\n    def start(self, melody_name: str):\n        if self.maestro.mute==True:\n            return\n        \"\"\"Begin fresh run through up to 4 hands.\"\"\"\n        self.current_melody = melody_name\n        self.current_hands  = self.melodies.get(melody_name, [])\n        self.idxs           = [0] * len(self.current_hands)\n        print(f\"[Compositor] Starting '{melody_name}' with {len(self.current_hands)} hand(s)\")\n\n    def next_event(self) -> Tuple[List[float], List[float], List[float]]:\n        if self.maestro.mute==True:\n            return\n        \"\"\"Return parallel lists: notes, durations, intensities.\"\"\"\n        if not self.current_hands:\n            return [0.0], [1.0], [0.0]\n        notes, durs, ints = [], [], []\n        for hi, hand in enumerate(self.current_hands):\n            f, d, i = hand[self.idxs[hi]]\n            notes.append(f)\n            durs.append(d)\n            ints.append(max(-1,i))\n            self.idxs[hi] = (self.idxs[hi] + 1) % len(hand)\n        #print(f\"[Compositor] next_event \u2192 notes={notes}, durs={durs}, ints={ints}\")\n        return notes, durs, ints\n\n    def get_full_sequence(self) -> Tuple[List[float], List[float], List[float]]:\n        if self.maestro.mute==True:\n            return\n        \"\"\"Return entire first\u2010hand sequence.\"\"\"\n        if not self.current_hands:\n            return [], [], []\n        evs   = self.current_hands[0]\n        return [f for f,_,_ in evs], [d for _,d,_ in evs], [i for _,_,i in evs]\n\n    def get_tempo(self, default: float) -> float:\n        if self.maestro.mute==True:\n            return\n        \"\"\"Return stored tempo or default.\"\"\"\n        return self.tempos.get(self.current_melody, default)\n\n    def get_meter(self) -> Tuple[int,int]:\n        if self.maestro.mute==True:\n            return\n        \"\"\"Return (beats_per_bar, beat_unit) or (4,4).\"\"\"\n        return self.meters.get(self.current_melody, (4,4))\n\n    def next_block_events(self, beats: float) -> List[Dict[str, Any]]:\n        if self.maestro.mute==True:\n            return\n        \"\"\"\n        Gather events until we've covered `beats` beats.\n        Returns a list of dicts:\n          {\"time\": beat_offset,\n           \"notes\": [...],\n           \"durations\": [...],\n           \"intensity\": [...]}\n        \"\"\"\n        events: List[Dict[str, Any]] = []\n        time_acc = 0.0\n        while time_acc < beats:\n            notes, durs, ints = self.next_event()\n            events.append({\n                \"time\":       time_acc,\n                \"notes\":      notes,\n                \"durations\":  durs,\n                \"intensity\":  ints\n            })\n            # advance by the average duration of this batch\n            time_acc += sum(durs) / len(durs)\n        return events\n"
        },
        {
            "file_path": "core/audio/maestro/maestro_mixer.py",
            "content": "#File:  audio/maestro_mixer.py \u00a9 2025 projectemergence. All rights reserved.\nimport numpy as np\nfrom collections import deque\n\nclass Mixer:\n    \"\"\"\n    Perform real-time spectral analysis and drive a parametric EQ.\n    \"\"\"\n    def __init__(self, client, sample_rate=48000, frame_size=1024):\n        self.client       = client\n        self.sr           = sample_rate\n        self.N            = frame_size\n        # rolling history of spectra for smoothing\n        self.history      = deque(maxlen=4)\n        # EQ band centers (Hz)\n        self.bands        = [125, 250, 500, 1000, 2000, 4000, 8000, 16000]\n        # initial gains\n        self.band_gains   = {b: 1.0 for b in self.bands}\n\n    def analyze_and_eq(self, audio_frame: np.ndarray):\n        \"\"\"\n        audio_frame: 1-D float32 buffer of length N.\n        \"\"\"\n        # 1) compute magnitude spectrum\n        spec = np.abs(np.fft.rfft(audio_frame * np.hanning(self.N)))\n        self.history.append(spec)\n        avg_spec = np.mean(self.history, axis=0)\n\n        # 2) for each band, find corresponding bin range\n        freqs = np.fft.rfftfreq(self.N, 1/self.sr)\n        for center in self.bands:\n            # find nearest bin\n            idx = np.argmin(np.abs(freqs - center))\n            magnitude = avg_spec[idx]\n            # map magnitude \u2192 desired gain (simple inverse)\n            # clamp between 0.5 and 1.0\n            gain = float(max(0.5, min(1.0, 1.0 - (magnitude / avg_spec.max())*0.5)))\n            # smooth update (one-pole)\n            self.band_gains[center] = 0.8*self.band_gains[center] + 0.2*gain\n            # push to client\u2019s EQ\n            self.client.set_eq_gain(center, self.band_gains[center])\n"
        },
        {
            "file_path": "core/audio/maestro/orchestrator.py",
            "content": "# File: src/core/audio/maestro/orchestrator.py  \u00a9 2025 projectemergence. All rights reserved.\n# orchestrator.py\nfrom music21 import chord, instrument\n\nREGISTER = {\n    'bass': (28, 48),      # E1\u2013C3\n    'piano': (50, 96),     # D3\u2013C7\n    'pad': (40, 84),\n    'lead': (60, 108),\n}\n\nclass Orchestrator:\n    def __init__(self):\n        self.occ = {name: 0 for name in REGISTER}\n\n    def voice(self, chords: list[str], rhythm: list[float]):\n        parts = {}\n        for symb, dur in zip(chords, rhythm):\n            c = chord.Chord(symb)\n            # FIX: c.bass() is a Pitch, so just .midi (no .pitch)\n            bass_note = c.bass().midi\n\n            # allocate bass\n            parts.setdefault('bass', {'notes': [], 'durations': [], 'intensity': []})\n            parts['bass']['notes'].append(self._fit(bass_note, 'bass'))\n            parts['bass']['durations'].append(dur)\n            parts['bass']['intensity'].append(.9)\n\n            # allocate chord tones to piano spread over two octaves\n            p_notes = [self._fit(n.pitch.midi, 'piano') for n in c.notes]\n            parts.setdefault('piano', {'notes': [], 'durations': [], 'intensity': []})\n            parts['piano']['notes'].extend(p_notes)\n            parts['piano']['durations'].extend([dur/len(p_notes)] * len(p_notes))\n            parts['piano']['intensity'].extend([.7] * len(p_notes))\n\n        return parts\n\n    def _fit(self, midi: int, role: str) -> int:\n        low, high = REGISTER[role]\n        while midi < low:\n            midi += 12\n        while midi > high:\n            midi -= 12\n        self.occ[role] += 1\n        return midi\n"
        },
        {
            "file_path": "core/audio/maestro/progression.py",
            "content": "# File: src/core/audio/maestro/progression.py  \u00a9 2025 projectemergence. All rights reserved.\n\nimport re\nimport random\nimport functools\nimport logging\nfrom typing import Dict, Any, List, Optional, Tuple\n\nimport music21.key as m21key\nimport music21.roman as roman\n\nlogger = logging.getLogger(__name__)\n\nclass ProgressionSynth:\n    \"\"\"\n    Rule\u2010based chord progression generator with caching:\n      \u2022 Caches next() by (key_str, beats, time_signature)\n      \u2022 Key objects & RomanNumeral creations memoized\n      \u2022 Graceful fallback on any parsing error\n    \"\"\"\n\n    GENRE_TEMPLATES: Dict[str, List[str]] = {\n        'pop':       ['I', 'V', 'vi', 'IV'],\n        'rock':      ['I', 'IV', 'V'],\n        'blues':     ['I', 'IV', 'I', 'V'],\n        'jazz':      ['ii', 'V', 'I'],\n        'classical': ['I', 'vi', 'ii', 'V'],\n        'funk':      ['I', 'bVII', 'IV', 'I'],\n    }\n\n    FUNCTION_MARKOV: Dict[str, List[str]] = {\n        'T': ['S']*3 + ['D']*2 + ['T'],\n        'S': ['D']*4 + ['T'],\n        'D': ['T']*5 + ['S'],\n    }\n\n    RN_TO_FUNCTION: Dict[str, str] = {\n        'I':'T','i':'T','vi':'T','VI':'T','III':'T','iii':'T',\n        'ii':'S','II':'S','IV':'S','iv':'S',\n        'V':'D','v':'D','vii\u00b0':'D','VII':'D'\n    }\n\n    def __init__(self, genre: str = 'pop', temperature: float = 0.5):\n        self.genre       = genre if genre in self.GENRE_TEMPLATES else None\n        self.temperature = max(0.0, min(1.0, temperature))\n\n        # cache helpers\n        self._key_obj     = functools.lru_cache(maxsize=32)(self._make_key)\n        self._rn_obj      = functools.lru_cache(maxsize=256)(self._make_roman)\n        self._next_cached = functools.lru_cache(maxsize=128)(self._next_uncached)\n\n    def next(self, analysis: Dict[str,Any], beats: float) -> List[str]:\n        \"\"\"\n        Public API: wraps cached _next_uncached, normalizing inputs.\n        \"\"\"\n        raw_key = analysis.get('key', 'C major')\n        # normalize flats/sharps\n        key_str = raw_key.translate(str.maketrans({'\u266d':'b','\u266f':'#'}))\n        # strip out any junk, collapse whitespace\n        key_str = re.sub(r'[^A-Za-z #]+', ' ', key_str).strip()\n        parts = key_str.split()\n        if len(parts) >= 2:\n            tonic, mode = parts[0].capitalize(), parts[1].lower()\n            if mode not in ('major','minor'):\n                mode = 'major'\n            key_str = f\"{tonic} {mode}\"\n        else:\n            key_str = \"C major\"\n\n        try:\n            return list(self._next_cached(key_str, beats, analysis.get('time_signature')))\n        except Exception as e:\n            logger.warning(f\"Progression failed for '{key_str}': {e}. Falling back to C major.\")\n            try:\n                return list(self._next_cached(\"C major\", beats, analysis.get('time_signature')))\n            except Exception as e2:\n                logger.error(f\"Fallback progression also failed: {e2}. Returning ['C'].\")\n                return ['C']\n\n    def _next_uncached(self,\n                       key_str: str,\n                       beats: float,\n                       time_signature: Optional[str]\n                      ) -> Tuple[str, ...]:\n        # 1) parse key\n        m21k = self._key_obj(key_str)\n\n        # 2) determine bar count\n        bar_beats = 4.0\n        if time_signature:\n            num, den = map(int, time_signature.split('/'))\n            bar_beats = num * (4/den)\n        n_bars = max(1, int(round(beats / bar_beats)))\n\n        # 3) choose Roman numerals\n        if self.genre:\n            tpl = self.GENRE_TEMPLATES[self.genre]\n            rns = (tpl * ((n_bars // len(tpl)) + 1))[:n_bars]\n        else:\n            rns, prev_fn = [], 'T'\n            for _ in range(n_bars):\n                fn = random.choice(self.FUNCTION_MARKOV[prev_fn])\n                choices = [rn for rn,f in self.RN_TO_FUNCTION.items() if f == fn]\n                rns.append(random.choice(choices))\n                prev_fn = fn\n\n        # 4) convert to chord symbols\n        chords = []\n        for rn in rns:\n            rn_obj = self._rn_obj(rn, key_str)\n            root    = rn_obj.root().name\n            quality = rn_obj.quality\n            chords.append(root + ('' if quality == 'major' else 'm'))\n        return tuple(chords)\n\n    def _make_key(self, key_str: str) -> m21key.Key:\n        parts = key_str.strip().split()\n        tonic = parts[0]\n        mode  = parts[1] if len(parts) >= 2 else 'major'\n        try:\n            # use the two\u2010argument Key constructor to avoid string\u2010parsing issues\n            return m21key.Key(tonic, mode)\n        except Exception as e:\n            logger.warning(f\"_make_key: Key({tonic!r}, {mode!r}) failed: {e}. Falling back to C major.\")\n            return m21key.Key('C', 'major')\n\n    def _make_roman(self, rn: str, key_str: str) -> roman.RomanNumeral:\n        try:\n            return roman.RomanNumeral(rn, self._key_obj(key_str))\n        except Exception as e:\n            logger.warning(f\"_make_roman: invalid RN '{rn}' in '{key_str}': {e}. Using I in C major.\")\n            return roman.RomanNumeral('I', self._key_obj(\"C major\"))\n"
        },
        {
            "file_path": "core/audio/maestro/resource_aware_arrangement_engine.py",
            "content": "#File:  audio/maestro/resource_aware_arrangement_engine.py \u00a9 2025 projectemergence. All rights reserved.\n# File: src/core/audio/maestro/resource_aware_arrangement_engine.py \u00a9 2025 projectemergence\nimport time\nimport psutil\nfrom collections import deque\nfrom core.audio.maestro.arrangement_engine import ArrangementEngine\n\nclass ResourceAwareArrangementEngine(ArrangementEngine):\n    def __init__(\n        self, client,\n        cpu_idle_threshold: float = 50.0,\n        mem_max_threshold: float = 85.0,\n        block_beats: float = 32.0,\n        max_queue_size: int = 4,\n        target_fps: float = 60.0\n    ):\n        super().__init__(client)\n        self.cpu_idle_threshold = cpu_idle_threshold\n        self.mem_max_threshold = mem_max_threshold\n        self.block_beats = block_beats\n        self.max_queue_size = max_queue_size\n        self.block_queue = deque()\n\n        # for tick-based correlation\n        self.target_dt = 1.0 / target_fps\n        self.last_tick = time.time()\n\n    def _wait_for_resources(self):\n        # Wait if CPU load or tick time too high\n        while psutil.cpu_percent(interval=0.05) > self.cpu_idle_threshold:\n            time.sleep(0.05)\n\n        # Tick-time correlation\n        current_tick = time.time()\n        actual_dt = current_tick - self.last_tick\n        self.last_tick = current_tick\n\n        if actual_dt > 1.2 * self.target_dt:  # threshold at 120% of target frame time\n            time.sleep(0.1)  # delay block prep if loop is behind\n\n    def prepare_block(self, beats: float = None):\n        beats = beats if beats else self.block_beats\n        self._wait_for_resources()\n\n        parts = super().prepare_block(beats)\n\n        # Memory-aware trimming\n        mem_usage = psutil.virtual_memory().percent\n        if mem_usage > self.mem_max_threshold:\n            keep = max(1, len(parts) // 2)\n            parts = dict(list(parts.items())[:keep])\n\n        # CPU-aware voice count scaling\n        cpu_usage = psutil.cpu_percent(interval=None)\n        max_voices = max(1, int(len(parts) * (1 - cpu_usage / 100)))\n        if len(parts) > max_voices:\n            parts = dict(list(parts.items())[:max_voices])\n\n        self.block_queue.append(parts)\n\n        # Maintain queue size\n        while len(self.block_queue) > self.max_queue_size:\n            self.block_queue.popleft()\n\n    def get_next_block(self, beats: float = None):\n        if not self.block_queue:\n            self.prepare_block(beats)\n        return self.block_queue.popleft()\n"
        },
        {
            "file_path": "core/audio/maestro/__init__.py",
            "content": "#File:  src/core/audio/__init__.py \u00a9 2025 projectemergence. All rights reserved.\n#File:  src/core/__init__.py \u00a9 2024 projectemergence. All rights reserved.\n# This file can be left empty, or you can use it to perform package-level initialization if needed.\n"
        },
        {
            "file_path": "core/audio/melodies/blue_Danube.json",
            "content": "{\n  \"title\": \"The Blue Danube (waltz theme)\",\n  \"composer\": \"Johann Strauss II\",\n  \"key\": \"D major\",\n  \"tempo\": 60,\n  \"time_signature\": \"3/4\",\n  \"notes\": [\n    {\"pitch\":\"F#4\",\"frequency\":369.99,\"duration_beats\":1},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":1},\n    {\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":1},\n    {\"pitch\":\"F#4\",\"frequency\":369.99,\"duration_beats\":1},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":1},\n    {\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":1}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/canon_D.json",
            "content": "{\n  \"title\": \"Canon in D (ground bass)\",\n  \"composer\": \"Johann Pachelbel\",\n  \"key\": \"D major\",\n  \"tempo\": 80,\n  \"time_signature\": \"4/4\",\n  \"notes\": [\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":4},\n    {\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":4},\n    {\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":4},\n    {\"pitch\":\"F#3\",\"frequency\":185.00,\"duration_beats\":4},\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":4},\n    {\"pitch\":\"D3\",\"frequency\":146.83,\"duration_beats\":4},\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":4},\n    {\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":4}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/Christians_awake.json",
            "content": "{\n  \"title\": \"Christians, Awake\",\n  \"composer\": \"Traditional (arr. Lowell Mason, extended)\",\n  \"key\": \"G major\",\n  \"tempo\": 100,\n  \"time_signature\": \"4/4\",\n  \"notes\": [\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":1},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":2},\n    {\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":1},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":2},\n\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":2},\n    \n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},\n    {\"pitch\":\"F#4\",\"frequency\":369.99,\"duration_beats\":1},\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2},\n\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1},\n    {\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":1},\n    {\"pitch\":\"D5\",\"frequency\":587.33,\"duration_beats\":2},\n\n    {\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":1},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":2},\n\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":1},\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/fur_elise.json",
            "content": "{\n  \"title\": \"F\u00fcr Elise, Bagatelle No. 25 in A minor\",\n  \"composer\": \"Ludwig van Beethoven\",\n  \"key\": \"A minor\",\n  \"tempo\": 120,\n  \"time_signature\": \"3/8\",\n  \"notes\": [\n    {\"pitch\": \"E5\",  \"frequency\": 659.25, \"duration_beats\": 0.5},\n    {\"pitch\": \"D#5\", \"frequency\": 622.25, \"duration_beats\": 0.5},\n    {\"pitch\": \"E5\",  \"frequency\": 659.25, \"duration_beats\": 0.5},\n    {\"pitch\": \"D#5\", \"frequency\": 622.25, \"duration_beats\": 0.5},\n    {\"pitch\": \"E5\",  \"frequency\": 659.25, \"duration_beats\": 0.5},\n    {\"pitch\": \"B4\",  \"frequency\": 493.88, \"duration_beats\": 0.5},\n    {\"pitch\": \"D5\",  \"frequency\": 587.33, \"duration_beats\": 0.5},\n    {\"pitch\": \"C5\",  \"frequency\": 523.25, \"duration_beats\": 0.5},\n    {\"pitch\": \"A4\",  \"frequency\": 440.00, \"duration_beats\": 1.0},\n\n    {\"pitch\": \"C4\",  \"frequency\": 261.63, \"duration_beats\": 0.5},\n    {\"pitch\": \"E4\",  \"frequency\": 329.63, \"duration_beats\": 0.5},\n    {\"pitch\": \"A4\",  \"frequency\": 440.00, \"duration_beats\": 1.0},\n\n    {\"pitch\": \"E5\",  \"frequency\": 659.25, \"duration_beats\": 0.5},\n    {\"pitch\": \"D#5\", \"frequency\": 622.25, \"duration_beats\": 0.5},\n    {\"pitch\": \"E5\",  \"frequency\": 659.25, \"duration_beats\": 0.5},\n    {\"pitch\": \"D#5\", \"frequency\": 622.25, \"duration_beats\": 0.5},\n    {\"pitch\": \"E5\",  \"frequency\": 659.25, \"duration_beats\": 0.5},\n    {\"pitch\": \"B4\",  \"frequency\": 493.88, \"duration_beats\": 0.5},\n    {\"pitch\": \"D5\",  \"frequency\": 587.33, \"duration_beats\": 0.5},\n    {\"pitch\": \"C5\",  \"frequency\": 523.25, \"duration_beats\": 0.5},\n    {\"pitch\": \"A4\",  \"frequency\": 440.00, \"duration_beats\": 1.0}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/Greensleeves.json",
            "content": "{\n  \"title\": \"Greensleeves\",\n  \"composer\": \"Traditional\",\n  \"key\": \"E minor\",\n  \"tempo\": 90,\n  \"time_signature\": \"6/8\",\n  \"notes\": [\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1},\n    {\"pitch\":\"E5\",\"frequency\":659.25,\"duration_beats\":2},\n    {\"pitch\":\"D5\",\"frequency\":587.33,\"duration_beats\":1},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/Gymnopedie.json",
            "content": "{\n  \"title\": \"Gymnop\u00e9die No. 1\",\n  \"composer\": \"Erik Satie\",\n  \"key\": \"D major\",\n  \"tempo\": 60,\n  \"time_signature\": \"3/4\",\n  \"notes\": [\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":3},\n    {\"pitch\":\"F#4\",\"frequency\":369.99,\"duration_beats\":3},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":3},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":3}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/Hyperforest_Fractal.json",
            "content": "{\n  \"title\": \"Hyperforest Fractal\",\n  \"composer\": \"EmergenceAI\",\n  \"created\": \"2025-04-28\",\n  \"mood\": \"labyrinthine serenity\",\n  \"description\": \"A sprawling, fractal\u2010driven generative piece in shifting meters. Four interlocking voices loop for hours, exchange motifs and remix themselves in a living soundscape.\",\n  \"poem\": \"In branching echoes forests rise,\\nEach leaf a note, each root a sigh.\\nTime unwinds in fractal flight,\\nInfinity in every night.\",\n  \"tempo\": 72,\n  \"time_signature\": \"5/4\",\n  \"structure\": [\n    { \"section\": \"A\", \"bars\": 4,  \"time_signature\": \"5/4\" },\n    { \"section\": \"B\", \"bars\": 7,  \"time_signature\": \"7/8\" },\n    { \"section\": \"C\", \"bars\": 11, \"time_signature\": \"11/8\" }\n  ],\n  \"variations\": 4,\n  \"remix\": {\n    \"self_shuffle\": 0.35,\n    \"exchange_ratio_range\": [0.2, 0.5],\n    \"transition_blocks\": 4\n  },\n  \"hands\": [\n    [  /* Hand 0: Deep bass ostinato (C2\u2013G3 pentatonic) */\n      { \"frequency\": 65.41, \"duration\": 1.00, \"intensity\": 0.85 },\n      { \"frequency\": 73.42, \"duration\": 0.75, \"intensity\": 0.88 },\n      { \"frequency\": 82.41, \"duration\": 1.25, \"intensity\": 0.82 },\n      { \"frequency\": 98.00, \"duration\": 0.50, \"intensity\": 0.90 },\n      { \"frequency\":110.00, \"duration\": 1.00, \"intensity\": 0.86 },\n      { \"frequency\":123.47, \"duration\": 0.75, \"intensity\": 0.90 },\n      { \"frequency\":130.81, \"duration\": 1.25, \"intensity\": 0.87 },\n      { \"frequency\":146.83, \"duration\": 0.50, \"intensity\": 0.89 },\n      { \"frequency\":164.81, \"duration\": 1.00, \"intensity\": 0.85 },\n      { \"frequency\":196.00, \"duration\": 0.75, \"intensity\": 0.88 },\n      { \"frequency\":220.00, \"duration\": 1.25, \"intensity\": 0.90 },\n      { \"frequency\":246.94, \"duration\": 0.50, \"intensity\": 0.86 },\n      { \"frequency\":261.63, \"duration\": 1.00, \"intensity\": 0.88 },\n      { \"frequency\":293.66, \"duration\": 0.75, \"intensity\": 0.90 },\n      { \"frequency\":329.63, \"duration\": 1.25, \"intensity\": 0.85 },\n      { \"frequency\":391.99, \"duration\": 0.50, \"intensity\": 0.90 }\n    ],\n    [  /* Hand 1: Warm mid-range arpeggio (C4\u2013B4) */\n      { \"frequency\":261.63, \"duration\": 0.50, \"intensity\": 0.60 },\n      { \"frequency\":329.63, \"duration\": 0.50, \"intensity\": 0.62 },\n      { \"frequency\":392.00, \"duration\": 0.50, \"intensity\": 0.64 },\n      { \"frequency\":523.25, \"duration\": 0.50, \"intensity\": 0.66 },\n      { \"frequency\":392.00, \"duration\": 0.50, \"intensity\": 0.68 },\n      { \"frequency\":329.63, \"duration\": 0.50, \"intensity\": 0.70 },\n      { \"frequency\":261.63, \"duration\": 0.50, \"intensity\": 0.65 },\n      { \"frequency\":196.00, \"duration\": 0.50, \"intensity\": 0.63 },\n      { \"frequency\":293.66, \"duration\": 0.50, \"intensity\": 0.60 },\n      { \"frequency\":369.99, \"duration\": 0.50, \"intensity\": 0.62 },\n      { \"frequency\":440.00, \"duration\": 0.50, \"intensity\": 0.64 },\n      { \"frequency\":554.37, \"duration\": 0.50, \"intensity\": 0.66 },\n      { \"frequency\":440.00, \"duration\": 0.50, \"intensity\": 0.68 },\n      { \"frequency\":369.99, \"duration\": 0.50, \"intensity\": 0.70 },\n      { \"frequency\":293.66, \"duration\": 0.50, \"intensity\": 0.65 },\n      { \"frequency\":246.94, \"duration\": 0.50, \"intensity\": 0.63 }\n    ],\n    [  /* Hand 2: Airy counter-motif (E5\u2013B5) */\n      { \"frequency\":659.25, \"duration\": 0.25, \"intensity\": 0.70 },\n      { \"frequency\":698.46, \"duration\": 0.25, \"intensity\": 0.72 },\n      { \"frequency\":783.99, \"duration\": 0.75, \"intensity\": 0.74 },\n      { \"frequency\":880.00, \"duration\": 0.50, \"intensity\": 0.76 },\n      { \"frequency\":783.99, \"duration\": 0.25, \"intensity\": 0.78 },\n      { \"frequency\":698.46, \"duration\": 0.75, \"intensity\": 0.80 },\n      { \"frequency\":659.25, \"duration\": 0.50, \"intensity\": 0.78 },\n      { \"frequency\":587.33, \"duration\": 0.25, \"intensity\": 0.76 },\n      { \"frequency\":523.25, \"duration\": 0.25, \"intensity\": 0.74 },\n      { \"frequency\":587.33, \"duration\": 0.75, \"intensity\": 0.72 },\n      { \"frequency\":659.25, \"duration\": 0.50, \"intensity\": 0.70 },\n      { \"frequency\":783.99, \"duration\": 0.25, \"intensity\": 0.72 },\n      { \"frequency\":880.00, \"duration\": 0.25, \"intensity\": 0.74 },\n      { \"frequency\":987.77, \"duration\": 0.75, \"intensity\": 0.76 },\n      { \"frequency\":783.99, \"duration\": 0.50, \"intensity\": 0.78 },\n      { \"frequency\":659.25, \"duration\": 0.25, \"intensity\": 0.80 }\n    ],\n    [  /* Hand 3: Metallic pulses (2\u20134 kHz sparkle) */\n      { \"frequency\":2000.00, \"duration\": 0.125, \"intensity\": 0.50 },\n      { \"frequency\":3000.00, \"duration\": 0.125, \"intensity\": 0.55 },\n      { \"frequency\":2500.00, \"duration\": 0.125, \"intensity\": 0.52 },\n      { \"frequency\":4000.00, \"duration\": 0.125, \"intensity\": 0.58 },\n      { \"frequency\":3500.00, \"duration\": 0.125, \"intensity\": 0.54 },\n      { \"frequency\":4500.00, \"duration\": 0.125, \"intensity\": 0.56 },\n      { \"frequency\":3000.00, \"duration\": 0.125, \"intensity\": 0.50 },\n      { \"frequency\":2500.00, \"duration\": 0.125, \"intensity\": 0.52 },\n      { \"frequency\":2000.00, \"duration\": 0.125, \"intensity\": 0.55 },\n      { \"frequency\":3000.00, \"duration\": 0.125, \"intensity\": 0.57 },\n      { \"frequency\":4000.00, \"duration\": 0.125, \"intensity\": 0.60 },\n      { \"frequency\":3500.00, \"duration\": 0.125, \"intensity\": 0.58 },\n      { \"frequency\":3000.00, \"duration\": 0.125, \"intensity\": 0.56 },\n      { \"frequency\":2500.00, \"duration\": 0.125, \"intensity\": 0.54 },\n      { \"frequency\":2000.00, \"duration\": 0.125, \"intensity\": 0.52 },\n      { \"frequency\":4000.00, \"duration\": 0.125, \"intensity\": 0.50 }\n    ]\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/la_folia.json",
            "content": "{\n  \"title\": \"La Folia\",\n  \"composer\": \"Traditional\",\n  \"key\": \"D minor\",\n  \"tempo\": 110,\n  \"time_signature\": \"4/4\",\n  \"notes\": [\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":2},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":2},\n    {\"pitch\":\"Bb4\",\"frequency\":466.16,\"duration_beats\":2},\n    {\"pitch\":\"F4\",\"frequency\":349.23,\"duration_beats\":2},\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":2},\n    {\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":2},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":2}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/minuet_G_Major.json",
            "content": "{\n  \"title\": \"Minuet in G Major\",\n  \"composer\": \"Christian Petzold\",\n  \"key\": \"G major\",\n  \"tempo\": 90,\n  \"time_signature\": \"3/4\",\n  \"notes\": [\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":1},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1},\n    {\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":1},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":1},\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":1}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/nocturne_E_FLat_Major.json",
            "content": "{\n  \"title\": \"Nocturne in E-flat Major, Op. 9 No. 2\",\n  \"composer\": \"Fr\u00e9d\u00e9ric Chopin\",\n  \"key\": \"E\u266d major\",\n  \"tempo\": 60,\n  \"time_signature\": \"12/8\",\n  \"notes\": [\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":1},{\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":2},\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":1},{\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":2},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":1},{\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":2},\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":1},{\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":2},\n\n    {\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":1},{\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":2},\n    {\"pitch\":\"F4\",\"frequency\":349.23,\"duration_beats\":1},{\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":2},\n    {\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":1},{\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":2},\n    {\"pitch\":\"F4\",\"frequency\":349.23,\"duration_beats\":1},{\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":2},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":2},\n    {\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":1},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":2},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":2},\n    {\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":1},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":2},\n\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":1},{\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":2},\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":1},{\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":2},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":1},{\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":2},\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":1},{\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":2},\n\n    {\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":1},{\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":2},\n    {\"pitch\":\"F4\",\"frequency\":349.23,\"duration_beats\":1},{\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":2},\n    {\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":1},{\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":2},\n    {\"pitch\":\"F4\",\"frequency\":349.23,\"duration_beats\":1},{\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":2},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":2},\n    {\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":1},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":2},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":2},\n    {\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":1},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":2},\n\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":0.5},{\"pitch\":\"G2\",\"frequency\":98.00,\"duration_beats\":0.5},\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":0.5},{\"pitch\":\"G2\",\"frequency\":98.00,\"duration_beats\":0.5},\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":0.5},{\"pitch\":\"G2\",\"frequency\":98.00,\"duration_beats\":0.5},\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":0.5},{\"pitch\":\"G2\",\"frequency\":98.00,\"duration_beats\":0.5},\n    {\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":1},{\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":1},\n    {\"pitch\":\"F3\",\"frequency\":174.61,\"duration_beats\":1},{\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":1},\n    {\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":1},{\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":1},\n    {\"pitch\":\"F3\",\"frequency\":174.61,\"duration_beats\":1},{\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":1},\n\n    {\"pitch\":\"D5\",\"frequency\":587.33,\"duration_beats\":0.5},{\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":0.5},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":0.5},{\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":0.5},\n    {\"pitch\":\"D5\",\"frequency\":587.33,\"duration_beats\":0.5},{\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":0.5},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":0.5},{\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":0.5},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"F4\",\"frequency\":349.23,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"F4\",\"frequency\":349.23,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":2},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":1},{\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":2},\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":1},{\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":2},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":1},{\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":2},\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":1},{\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":2},\n\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":2},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":2},\n    {\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":2},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":2},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":2},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":2},\n    {\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":2},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":2}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/ode_to_joy.json",
            "content": "{\n  \"title\": \"Ode to Joy\",\n  \"composer\": \"Ludwig van Beethoven\",\n  \"key\": \"D major\",\n  \"tempo\": 100,\n  \"time_signature\": \"4/4\",\n  \"notes\": [\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},\n    {\"pitch\":\"F#4\",\"frequency\":369.99,\"duration_beats\":1},\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"F#4\",\"frequency\":369.99,\"duration_beats\":1},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":1},\n    {\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":1},\n    {\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":1},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":1},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1.5},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":0.5}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/prelude_C_Major.json",
            "content": "{\n  \"title\": \"Prelude in C Major\",\n  \"composer\": \"Johann Sebastian Bach\",\n  \"key\": \"C major\",\n  \"tempo\": 120,\n  \"time_signature\": \"4/4\",\n  \"notes\": [\n    {\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":0.5},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":0.5},\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":0.5},\n    {\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":0.5},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":0.5},\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":0.5},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":0.5},\n    {\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":0.5}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/prelude_D_minor.json",
            "content": "{\n  \"title\": \"Prelude in D Minor, BWV 851\",\n  \"composer\": \"Johann Sebastian Bach\",\n  \"key\": \"D minor\",\n  \"tempo\": 100,\n  \"time_signature\": \"4/4\",\n  \"notes\": [\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":0.5},\n    {\"pitch\":\"F4\",\"frequency\":349.23,\"duration_beats\":0.5},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":0.5},\n    {\"pitch\":\"D5\",\"frequency\":587.33,\"duration_beats\":0.5},\n    {\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":0.5},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":0.5},\n    {\"pitch\":\"F4\",\"frequency\":349.23,\"duration_beats\":0.5},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":0.5},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":0.5},\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":0.5},\n    {\"pitch\":\"B\u266d4\",\"frequency\":466.16,\"duration_beats\":0.5},\n    {\"pitch\":\"D5\",\"frequency\":587.33,\"duration_beats\":0.5},\n    {\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":0.5},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":0.5},\n    {\"pitch\":\"F4\",\"frequency\":349.23,\"duration_beats\":0.5},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":0.5}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/Revolutionary_opening.json",
            "content": "{\n  \"title\": \"\u00c9tude Op.10 No.12 \u201cRevolutionary\u201d (opening)\",\n  \"composer\": \"Fr\u00e9d\u00e9ric Chopin\",\n  \"key\": \"C minor\",\n  \"tempo\": 144,\n  \"time_signature\": \"2/4\",\n  \"notes\": [\n    {\"pitch\":\"C3\",\"frequency\":130.81,\"duration_beats\":0.5},\n    {\"pitch\":\"C2\",\"frequency\":65.41,\"duration_beats\":0.5},\n    {\"pitch\":\"C3\",\"frequency\":130.81,\"duration_beats\":0.5},\n    {\"pitch\":\"C2\",\"frequency\":65.41,\"duration_beats\":0.5},\n    {\"pitch\":\"C3\",\"frequency\":130.81,\"duration_beats\":0.5},\n    {\"pitch\":\"C2\",\"frequency\":65.41,\"duration_beats\":0.5},\n    {\"pitch\":\"C3\",\"frequency\":130.81,\"duration_beats\":0.5},\n    {\"pitch\":\"C2\",\"frequency\":65.41,\"duration_beats\":0.5},\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"E\u266d4\",\"frequency\":311.13,\"duration_beats\":1},\n    {\"pitch\":\"F4\",\"frequency\":349.23,\"duration_beats\":1},\n    {\"pitch\":\"D\u266d4\",\"frequency\":277.18,\"duration_beats\":1},\n    {\"pitch\":\"E\u266d4\",\"frequency\":311.13,\"duration_beats\":1},\n    {\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":1},\n    {\"pitch\":\"D\u266d4\",\"frequency\":277.18,\"duration_beats\":1},\n    {\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":1}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/Rondo_d_Major.json",
            "content": "{\n  \"title\": \"Rondo in D Major, K. 485 (theme)\",\n  \"composer\": \"Wolfgang Amadeus Mozart\",\n  \"key\": \"D major\",\n  \"tempo\": 144,\n  \"time_signature\": \"12/8\",\n  \"notes\": [\n    {\"pitch\":\"D5\",\"frequency\":587.33,\"duration_beats\":1},\n    {\"pitch\":\"F#5\",\"frequency\":739.99,\"duration_beats\":1},\n    {\"pitch\":\"A5\",\"frequency\":880.00,\"duration_beats\":1},\n    {\"pitch\":\"B5\",\"frequency\":987.77,\"duration_beats\":1},\n    {\"pitch\":\"A5\",\"frequency\":880.00,\"duration_beats\":1},\n    {\"pitch\":\"F#5\",\"frequency\":739.99,\"duration_beats\":1},\n    {\"pitch\":\"D5\",\"frequency\":587.33,\"duration_beats\":1},\n    {\"pitch\":\"C#5\",\"frequency\":554.37,\"duration_beats\":1},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":1},\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"F#4\",\"frequency\":369.99,\"duration_beats\":1},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":2},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":2}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/scarborough_fair.json",
            "content": "{\n  \"title\": \"Scarborough Fair (melody)\",\n  \"composer\": \"Traditional\",\n  \"key\": \"E minor\",\n  \"tempo\": 85,\n  \"time_signature\": \"3/4\",\n  \"notes\": [\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":1},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":1},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":1},\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":2}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/Shadow_descent.json",
            "content": "{\n  \"title\": \"\u00c9tude in D-minor \u201cShadow Descent\u201d\",\n  \"composer\": \"ChatGPT (public domain)\",\n  \"key\": \"D minor\",\n  \"tempo\": 72,\n  \"time_signature\": \"4/4\",\n  \"notes\": [\n\n    {\"pitch\":\"D3\",\"frequency\":146.83,\"duration_beats\":1},{\"pitch\":\"A2\",\"frequency\":110.00,\"duration_beats\":1},\n    {\"pitch\":\"D3\",\"frequency\":146.83,\"duration_beats\":1},{\"pitch\":\"C3\",\"frequency\":130.81,\"duration_beats\":1},\n    {\"pitch\":\"F3\",\"frequency\":174.61,\"duration_beats\":1},{\"pitch\":\"D3\",\"frequency\":146.83,\"duration_beats\":1},\n    {\"pitch\":\"F3\",\"frequency\":174.61,\"duration_beats\":1},{\"pitch\":\"E3\",\"frequency\":164.81,\"duration_beats\":1},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":0.5},{\"pitch\":\"C#4\",\"frequency\":277.18,\"duration_beats\":0.5},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":0.5},{\"pitch\":\"C#4\",\"frequency\":277.18,\"duration_beats\":0.5},\n    {\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":1},{\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":1},\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":2},\n\n    {\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":0.5},{\"pitch\":\"A#3\",\"frequency\":233.08,\"duration_beats\":0.5},\n    {\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":0.5},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":0.5},\n    {\"pitch\":\"C#4\",\"frequency\":277.18,\"duration_beats\":0.5},{\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":0.5},\n    {\"pitch\":\"D#4\",\"frequency\":311.13,\"duration_beats\":0.5},{\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":0.5},\n    {\"pitch\":\"F4\",\"frequency\":349.23,\"duration_beats\":1},{\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":1},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":1},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":1},\n    {\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":1},{\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":1},\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":2},\n\n    {\"pitch\":\"D3\",\"frequency\":146.83,\"duration_beats\":0.5},{\"pitch\":\"F3\",\"frequency\":174.61,\"duration_beats\":0.5},\n    {\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":0.5},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":0.5},\n    {\"pitch\":\"D3\",\"frequency\":146.83,\"duration_beats\":0.5},{\"pitch\":\"F3\",\"frequency\":174.61,\"duration_beats\":0.5},\n    {\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":0.5},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":0.5},\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":1},{\"pitch\":\"C#4\",\"frequency\":277.18,\"duration_beats\":1},\n    {\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":1},{\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":1},\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":1},{\"pitch\":\"F3\",\"frequency\":174.61,\"duration_beats\":1},\n    {\"pitch\":\"E3\",\"frequency\":164.81,\"duration_beats\":2},\n\n    {\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":0.5},{\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":0.5},\n    {\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":0.5},{\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":0.5},\n    {\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":0.5},{\"pitch\":\"F3\",\"frequency\":174.61,\"duration_beats\":0.5},\n    {\"pitch\":\"E3\",\"frequency\":164.81,\"duration_beats\":0.5},{\"pitch\":\"D3\",\"frequency\":146.83,\"duration_beats\":0.5},\n    {\"pitch\":\"C3\",\"frequency\":130.81,\"duration_beats\":1},{\"pitch\":\"B2\",\"frequency\":123.47,\"duration_beats\":1},\n    {\"pitch\":\"A2\",\"frequency\":110.00,\"duration_beats\":1},{\"pitch\":\"G2\",\"frequency\":98.00,\"duration_beats\":1},\n    {\"pitch\":\"F2\",\"frequency\":87.31,\"duration_beats\":1},{\"pitch\":\"E2\",\"frequency\":82.41,\"duration_beats\":1},\n    {\"pitch\":\"D2\",\"frequency\":73.42,\"duration_beats\":2},\n\n    {\"pitch\":\"D2\",\"frequency\":73.42,\"duration_beats\":0.25},{\"pitch\":\"A1\",\"frequency\":55.00,\"duration_beats\":0.25},\n    {\"pitch\":\"D2\",\"frequency\":73.42,\"duration_beats\":0.25},{\"pitch\":\"A1\",\"frequency\":55.00,\"duration_beats\":0.25},\n    {\"pitch\":\"D2\",\"frequency\":73.42,\"duration_beats\":0.25},{\"pitch\":\"A1\",\"frequency\":55.00,\"duration_beats\":0.25},\n    {\"pitch\":\"D2\",\"frequency\":73.42,\"duration_beats\":0.25},{\"pitch\":\"A1\",\"frequency\":55.00,\"duration_beats\":0.25},\n    {\"pitch\":\"D2\",\"frequency\":73.42,\"duration_beats\":0.25},{\"pitch\":\"A1\",\"frequency\":55.00,\"duration_beats\":0.25},\n    {\"pitch\":\"D2\",\"frequency\":73.42,\"duration_beats\":0.25},{\"pitch\":\"A1\",\"frequency\":55.00,\"duration_beats\":0.25},\n    {\"pitch\":\"D2\",\"frequency\":73.42,\"duration_beats\":0.25},{\"pitch\":\"A1\",\"frequency\":55.00,\"duration_beats\":0.25},\n    {\"pitch\":\"D2\",\"frequency\":73.42,\"duration_beats\":0.25},{\"pitch\":\"A1\",\"frequency\":55.00,\"duration_beats\":0.25},\n\n    {\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":0.5},{\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":0.5},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":0.5},{\"pitch\":\"G#4\",\"frequency\":415.30,\"duration_beats\":0.5},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":0.5},{\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":0.5},\n    {\"pitch\":\"C5\",\"frequency\":523.25,\"duration_beats\":0.5},{\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":0.5},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"F#4\",\"frequency\":369.99,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n    {\"pitch\":\"F#4\",\"frequency\":369.99,\"duration_beats\":1},{\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":1},\n\n    {\"pitch\":\"D5\",\"frequency\":587.33,\"duration_beats\":0.5},{\"pitch\":\"C#5\",\"frequency\":554.37,\"duration_beats\":0.5},\n    {\"pitch\":\"B4\",\"frequency\":493.88,\"duration_beats\":0.5},{\"pitch\":\"A4\",\"frequency\":440.00,\"duration_beats\":0.5},\n    {\"pitch\":\"G4\",\"frequency\":392.00,\"duration_beats\":0.5},{\"pitch\":\"F4\",\"frequency\":349.23,\"duration_beats\":0.5},\n    {\"pitch\":\"E4\",\"frequency\":329.63,\"duration_beats\":0.5},{\"pitch\":\"D4\",\"frequency\":293.66,\"duration_beats\":0.5},\n    {\"pitch\":\"C4\",\"frequency\":261.63,\"duration_beats\":1},{\"pitch\":\"B3\",\"frequency\":246.94,\"duration_beats\":1},\n    {\"pitch\":\"A3\",\"frequency\":220.00,\"duration_beats\":1},{\"pitch\":\"G3\",\"frequency\":196.00,\"duration_beats\":1},\n    {\"pitch\":\"F3\",\"frequency\":174.61,\"duration_beats\":1},{\"pitch\":\"E3\",\"frequency\":164.81,\"duration_beats\":1},\n    {\"pitch\":\"D3\",\"frequency\":146.83,\"duration_beats\":2},\n\n    {\"pitch\":\"D2\",\"frequency\":73.42,\"duration_beats\":0.5},{\"pitch\":\"Rest\",\"frequency\":0,\"duration_beats\":0.5},\n    {\"pitch\":\"D2\",\"frequency\":73.42,\"duration_beats\":0.5},{\"pitch\":\"Rest\",\"frequency\":0,\"duration_beats\":0.5},\n    {\"pitch\":\"D2\",\"frequency\":73.42,\"duration_beats\":0.5},{\"pitch\":\"Rest\",\"frequency\":0,\"duration_beats\":0.5},\n    {\"pitch\":\"D2\",\"frequency\":73.42,\"duration_beats\":0.5},{\"pitch\":\"Rest\",\"frequency\":0,\"duration_beats\":0.5},\n    {\"pitch\":\"C2\",\"frequency\":65.41,\"duration_beats\":1},{\"pitch\":\"Rest\",\"frequency\":0,\"duration_beats\":1},\n    {\"pitch\":\"A1\",\"frequency\":55.00,\"duration_beats\":1},{\"pitch\":\"Rest\",\"frequency\":0,\"duration_beats\":1},\n    {\"pitch\":\"D2\",\"frequency\":73.42,\"duration_beats\":2},{\"pitch\":\"Rest\",\"frequency\":0,\"duration_beats\":2}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/melodies/walt_of_the_flowers.json",
            "content": "{\n  \"title\": \"Waltz of the Flowers\",\n  \"composer\": \"Pyotr Ilyich Tchaikovsky\",\n  \"key\": \"D major\",\n  \"tempo\": 120,\n  \"time_signature\": \"3/4\",\n  \"notes\": [\n    {\"pitch\":\"D5\",\"frequency\":587.33,\"duration_beats\":1},\n    {\"pitch\":\"F#5\",\"frequency\":739.99,\"duration_beats\":1},\n    {\"pitch\":\"A5\",\"frequency\":880.00,\"duration_beats\":1},\n    {\"pitch\":\"D6\",\"frequency\":1174.66,\"duration_beats\":2},\n    {\"pitch\":\"C6\",\"frequency\":1046.50,\"duration_beats\":1}\n  ]\n}\n"
        },
        {
            "file_path": "core/audio/presets/base_preset.py",
            "content": "# File: audio/presets/base_preset.py \u00a9 2025 projectemergence. All rights reserved.\n# File: src/core/audio/presets/base_preset.py\n\nfrom abc import ABC, abstractmethod\nimport time\nfrom pyo import (Fader, Pan, SigTo, Freeverb, Chorus, ButLP, Sine)\nimport inspect\nfrom typing import ClassVar, Dict, Type, Any\n\nclass PresetMeta(type):\n    _registry: ClassVar[Dict[str, Type['BasePreset']]] = {}\n\n    def __init__(cls, name: str, bases: tuple, namespace: dict[str, Any]):\n        super().__init__(name, bases, namespace)\n        # skip the abstract BasePreset itself\n        if bases and BasePreset in bases:\n            mod_name = cls.__module__.split('.')[-1]\n            PresetMeta._registry[mod_name] = cls\n\nclass BasePreset(metaclass=PresetMeta):\n\n    supports_melody: bool = True\n    def __init__(\n        self,\n        intensity: float | list[float]       = 0.7,\n        duration:  float | None               = 2.0,\n        freq1:     float | None               = None,\n        freq2:     float | None               = None,\n        # \u2500\u2500\u2500 optional melody parameters \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        notes:      list[float] | None        = None,\n        durations:  list[float] | None        = None,\n        intensities:list[float] | None        = None,\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        pan_pos:   float                      = 0.0,\n        stereo_w:  float                      = 0.0,\n        enable_reverb: bool                   = False,\n        enable_chorus: bool                   = False,\n        enable_filter: bool                   = False,\n        filt_freq: float                      = 1200,\n        **extra\n    ):\n        # allow either a single float or per-note list\n        if isinstance(intensity, list):\n            self._per_note_intensities = intensity\n            base_int = max(intensity) if intensity else 0.0\n        else:\n            self._per_note_intensities = None\n            base_int = intensity\n\n        self.intensity     = max(base_int, 0.0)\n        self.duration      = duration\n        self.freq1, self.freq2 = freq1, freq2\n        self._pan_pos      = max(min(pan_pos, 1), -1)\n        self.stereo_w      = max(min(stereo_w, 1), 0)\n        self.enable_reverb = enable_reverb\n        self.enable_chorus = enable_chorus\n        self.enable_filter = enable_filter\n        self.filt_freq     = filt_freq\n        self._keep_alive   = []               # guard vs GC\n\n        # \u2500\u2500\u2500 store optional melody \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        self.notes         = notes\n        self.durations     = durations\n        self._melody_ints  = intensities\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n    def _env(self, fade=.005) -> Fader:\n        dur = self.duration or 0\n        return Fader(fadein=fade, fadeout=fade*4, dur=dur, mul=self.intensity)\n\n    def _fx_chain(self, sig):\n        if self.enable_filter:\n            sig = ButLP(sig, freq=self.filt_freq)\n        if self.enable_chorus and self.stereo_w:\n            sig = Chorus(sig, depth=.8*self.stereo_w, feedback=.25, bal=.5)\n        if self.enable_reverb:\n            sig = Freeverb(sig, size=.8, bal=.35)\n        if self._pan_pos or self.stereo_w:\n            sig = Pan(sig, outs=2, pan=self._pan_pos)\n        return sig\n\n    def _keep(self, *objs):\n        self._keep_alive.extend(objs)\n        return objs[0] if objs else None\n\n    @abstractmethod\n    def _build(self):\n        \"\"\"\n        Subclasses must return either\n          \u2022 a single Pyo object (dry signal), or\n          \u2022 a list of (Fader, Pyo-object) tuples for sequences.\n        \"\"\"\n\n    def play(self):\n        # \u2500\u2500\u2500 if a melody was passed in, override build() \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        if self.notes and self.durations:\n            seq = []\n            # intensities: explicit -> per-note list -> fallback to base\n            ints = (\n                self._melody_ints\n                or self._per_note_intensities\n                or [self.intensity] * len(self.notes)\n            )\n            for f, d, i in zip(self.notes, self.durations, ints):\n                env = Fader(fadein=0.005, fadeout=0.02, dur=d, mul=i)\n                osc = Sine(freq=f, mul=env)\n                seq.append((env, osc))\n            built = seq\n        else:\n            built = self._build()\n\n        # sequence-of-notes case\n        if isinstance(built, list):\n            for fader, sig in built:\n                fader.play()\n                out = self._fx_chain(sig)\n                self._keep(out).out()\n            return built\n\n        # single-shot case\n        dry = built\n        wet = self._fx_chain(dry)\n        self._keep(wet).out()\n        return wet\n\n    def _sweep(self, start_freq, end_freq, duration, exp=False):\n        \"\"\"\n        Glide from start_freq to end_freq over a given duration.\n        \"\"\"\n        step = (end_freq - start_freq) / duration\n        current = start_freq\n        dt = 0.01\n        start = time.time()\n        while abs(time.time() - start) < duration:\n            current += step * dt\n        return end_freq\n"
        },
        {
            "file_path": "core/audio/presets/bass.py",
            "content": "# File: src/core/audio/presets/bass.py \u00a9 2025 projectemergence. All rights reserved.\n# Defines the Bass preset, with optional distortion. _build() added for architecture support.\n\nfrom pyo import Sine, Fader, Disto\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Bass(BasePreset):\n    def __init__(\n        self,\n        intensity=0.98,\n        duration=0.65,\n        base_freq=1318.2567385564075,\n        fade_in=0.0,\n        fade_out=0.0,\n        tone_freq_ratio=223.872113856834,\n        tone_mul_factor=0.62,\n        dist_drive=0.35,\n        dist_slope=0.44,\n        dist_mul_factor=0.56,\n    ):\n        super().__init__(intensity * 2, duration)\n        # core inputs\n        self.base_freq = 1318.2567385564075\n        # fader constants\n        self.fade_in = 0.0\n        self.fade_out = 0.0\n        # tone constants\n        self.tone_freq_ratio = 223.872113856834\n        self.tone_mul_factor = 0.62\n        # distortion constants\n        self.dist_drive = 0.35\n        self.dist_slope = 0.44\n        self.dist_mul_factor = 0.56\n\n    def _build(self):\n        # use named attributes everywhere instead of literals\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration * 2,\n            mul=self.intensity\n        )\n        tone = Sine(\n            freq=self.base_freq * self.tone_freq_ratio,\n            mul=fader * self.tone_mul_factor\n        )\n        distorted = Disto(\n            tone,\n            drive=self.dist_drive,\n            slope=self.dist_slope,\n            mul=self.intensity * self.dist_mul_factor\n        )\n        self.chain = {\"fader\": fader, \"tone\": tone, \"distorted\": distorted}\n        return self.chain\n\n    def play(self):\n        chain = self._build()\n        chain[\"fader\"].play()\n        chain[\"distorted\"].out()\n        return chain\n"
        },
        {
            "file_path": "core/audio/presets/big_kick.py",
            "content": "# File: audio/presets/big_kick.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n# \u00a9 2025 projectemergence \u2013 v2\n\n\"\"\"\nBigKick 2.0 \u2013 modern electronic kick\n\u2022 body: exponential sine sweep for punch\n\u2022 click: tight noise burst with band-pass\n\u2022 sub: optional low sine layer\n\u2022 gating and HPF to remove noise floor\n\u2022 antialias filtering around waveshaper\n\"\"\"\n\nfrom pyo import Sine, Noise, ButBP, ButHP, Fader, Clip, Biquad, Gate\nfrom core.audio.presets.base_preset import BasePreset\n\nclass BigKick(BasePreset):\n    def __init__(\n        self,\n        intensity=0.68,\n        duration=0.6,\n        freq1=160,\n        freq2=45,\n        click_len=0.015,\n        click_freq=5000,\n        add_sub=True,\n        soft_clip=True,\n        gate_thresh=0.001,\n        body_env_fadein=0.002,\n        body_sweep_ratio=0.89,\n        click_env_fadein=0.0005,\n        click_env_fadeout_ratio=0.7,\n        click_mul_factor=0.35,\n        click_bp_q=10.0,\n        sub_freq_ratio=0.5,\n        sub_mul_factor=0.5,\n        lpf_freq=20000.0,\n        lpf_q=0.707,\n        lpf_type=1,\n        clip_min=-0.9,\n        clip_max=0.9,\n        hpf_freq=20.0,\n        hpf_q=0.707,\n        hpf_type=2,\n        **kw\n    ):\n        kw.setdefault('stereo_w', 0.0)\n        kw.setdefault('enable_reverb', False)\n        super().__init__(intensity=0.68,\n                         duration=0.6,\n                         freq1=160,\n                         freq2=45,\n                         **kw)\n\n        # click parameters\n        self.click_len = 0.015\n        self.click_freq = 5000\n\n        # behavior flags\n        self.add_sub = True\n        self.soft_clip = True\n        self.gate_thresh = 0.001\n\n        # body envelope / sweep\n        self.body_env_fadein = 0.002\n        self.body_sweep_ratio = 0.89\n\n        # click envelope\n        self.click_env_fadein = 0.0005\n        self.click_env_fadeout_ratio = 0.7\n        self.click_mul_factor = 0.35\n        self.click_bp_q = 10.0\n\n        # sub oscillator\n        self.sub_freq_ratio = 0.5\n        self.sub_mul_factor = 0.5\n\n        # soft-clip / antialias filter\n        self.lpf_freq = 20000.0\n        self.lpf_q = 0.707\n        self.lpf_type = 1\n        self.clip_min = -0.9\n        self.clip_max = 0.9\n\n        # final high-pass filter\n        self.hpf_freq = 20.0\n        self.hpf_q = 0.707\n        self.hpf_type = 2\n\n    def _make_body(self, env):\n        # exponential sweep for psycho-acoustic punch\n        glide = self._sweep(\n            self.freq1,\n            self.freq2,\n            self.duration * self.body_sweep_ratio,\n            exp=True\n        )\n        return Sine(freq=glide, mul=env)\n\n    def _make_click(self):\n        env = Fader(\n            fadein=self.click_env_fadein,\n            fadeout=self.click_len * self.click_env_fadeout_ratio,\n            dur=self.click_len,\n            mul=self.intensity * self.click_mul_factor\n        ).play()\n        noise = Noise(mul=env)\n        return ButBP(noise, freq=self.click_freq, q=self.click_bp_q)\n\n    def _make_sub(self, env):\n        sub_freq = max(self.freq2 * self.sub_freq_ratio, 20.0)\n        return Sine(freq=sub_freq, mul=env * self.sub_mul_factor)\n\n    def _build(self):\n        # body envelope\n        body_env = self._env(self.body_env_fadein)\n\n        # components\n        parts = [\n            self._make_body(body_env),\n            self._make_click()\n        ]\n        if self.add_sub:\n            parts.append(self._make_sub(body_env))\n\n        mix = sum(parts)\n\n        if self.soft_clip:\n            # antialias LPF before clipping\n            mix = Biquad(\n                mix,\n                freq=self.lpf_freq,\n                q=self.lpf_q,\n                type=self.lpf_type\n            )\n            mix = Clip(mix, min=self.clip_min, max=self.clip_max)\n\n        # gate to remove residual noise\n        gated = Gate(mix, thresh=self.gate_thresh)\n\n        # high-pass to remove subsonic rumble\n        return Biquad(\n            gated,\n            freq=self.hpf_freq,\n            q=self.hpf_q,\n            type=self.hpf_type\n        )\n"
        },
        {
            "file_path": "core/audio/presets/cello.py",
            "content": "# File: src/core/audio/presets/cello.py \u00a9 2025 projectemergence. All rights reserved.\n# Defines a resonant cello tone. _build() added for architecture support.\n\nfrom pyo import Sine, Fader, Freeverb\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Cello(BasePreset):\n    def __init__(\n        self,\n        intensity=0.5,\n        duration=1.19,\n        base_freq=216.0,\n        freq_multiplier=3.0,\n        fade_in=0.2,\n        fade_out=4.29,\n        dur_multiplier=2.08,\n        fader_mul_factor=0.95,\n        tone_mul_factor=2.0,\n        reverb_input_div=2.0,\n        reverb_size=0.76,\n        reverb_bal=0.93,\n    ):\n        super().__init__(intensity, duration)\n        # core inputs\n        self.base_freq = 20.0 * freq_multiplier\n\n        # fader settings\n        self.fade_in = 0.2\n        self.fade_out = 4.29\n        self.dur_multiplier = 2.08\n        self.fader_mul_factor = 0.95\n\n        # tone settings\n        self.tone_mul_factor = 2.0\n\n        # reverb settings\n        self.reverb_input_div = 2.0\n        self.reverb_size = 0.76\n        self.reverb_bal = 0.93\n\n    def _build(self):\n        # amplitude envelope\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration * self.dur_multiplier,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        # core sine tone\n        tone = Sine(\n            freq=self.base_freq,\n            mul=fader * self.tone_mul_factor\n        )\n        # reverb effect\n        reverb = Freeverb(\n            tone / self.reverb_input_div,\n            size=self.reverb_size,\n            bal=self.reverb_bal\n        )\n        self.chain = {\"fader\": fader, \"tone\": tone, \"reverb\": reverb}\n        return self.chain\n\n    def play(self):\n        chain = self._build()\n        chain[\"fader\"].play()\n        chain[\"reverb\"].out()\n        return chain\n"
        },
        {
            "file_path": "core/audio/presets/chorus.py",
            "content": "# File: core/audio/presets/chorus.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\nfrom pyo import Noise, Chorus\nfrom core.audio.presets.base_preset import BasePreset\n\nclass ChorusPreset(BasePreset):\n    \"\"\"A simple chorus/noise layer that can thicken the drone.\"\"\"\n    def __init__(\n        self,\n        *,\n        visual_metric: float = 0.0,\n        noise_vol=0.1,\n        feedback=0.6,\n        bal=0.5\n    ):\n        super().__init__()\n        self.depth = 1.0 + visual_metric * 0.5\n        self.noise_vol=noise_vol\n        self.feedback=feedback\n        self.bal=bal\n\n    def play(self):\n        return Chorus(Noise(mul=self.noise_vol),\n                      depth=self.depth,\n                      feedback=self.feedback,\n                      bal=self.bal).out()\n    def _build(self):\n        # fade-in only once, then hold\n        env = Fader(fadein=0.01, fadeout=1.0, dur=0.8, mul=0.1).play()\n        # noise source into chorus\n        noise = Noise(mul=env)\n        return Chorus(self.noise, depth=self.depth, feedback=self.feedback, bal=self.bal)\n"
        },
        {
            "file_path": "core/audio/presets/clarinet.py",
            "content": "# File: src/core/audio/presets/clarinet.py \u00a9 2025 projectemergence. All rights reserved.\n# Defines a clarinet sound with filter and distortion. _build() added for architecture support.\n\nfrom pyo import Sine, Fader, Disto, ButLP\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Clarinet(BasePreset):\n    def __init__(\n        self,\n        intensity=0.83,\n        duration=2.2,\n        base_freq=20.0,\n        fade_in=0.05,\n        fade_out=0.5,\n        fader_mul_factor=0.26,\n        dist_drive=0.6,\n        dist_slope=0.3,\n        dist_mul_factor=1.0,\n        filter_freq=800.0,\n    ):\n        super().__init__(intensity, duration)\n        # core\n        self.base_freq = 20.0\n        # fader settings\n        self.fade_in = 0.05\n        self.fade_out = 0.5\n        self.fader_mul_factor = 0.26\n        # distortion settings\n        self.dist_drive = 0.6\n        self.dist_slope = 0.3\n        self.dist_mul_factor = 1.0\n        # filter settings\n        self.filter_freq = 800.0\n\n    def _build(self):\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        tone = Sine(\n            freq=self.base_freq,\n            mul=fader\n        )\n        distorted = Disto(\n            tone,\n            drive=self.dist_drive,\n            slope=self.dist_slope,\n            mul=self.dist_mul_factor\n        )\n        filtered = ButLP(\n            distorted,\n            freq=self.filter_freq\n        )\n        self.chain = {\n            \"fader\": fader,\n            \"tone\": tone,\n            \"distorted\": distorted,\n            \"filtered\": filtered\n        }\n        return self.chain\n\n    def play(self):\n        chain = self._build()\n        chain[\"fader\"].play()\n        chain[\"filtered\"].out()\n        return chain\n"
        },
        {
            "file_path": "core/audio/presets/digital_snap.py",
            "content": "# File: src/core/audio/presets/digital_snap.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nDigitalSnap \u2013 hyper-tight click percussion with bit-crush and comb-style delay.\n\"\"\"\n\nfrom pyo import Noise, Fader, Degrade, SmoothDelay, ButHP\nfrom core.audio.presets.base_preset import BasePreset\n\nclass DigitalSnap(BasePreset):\n    def __init__(\n        self,\n        intensity=0.8,\n        duration=1.01,\n        bit_depth=6,\n        sr_scale=0.0,\n        comb_delay=0.04,\n        comb_feedback=0.0,\n        hpf_freq=138.93,\n        fade_in=0.001,\n        fade_out=0.02,\n        crossfade=0.01,\n        **kw\n    ):\n        kw.setdefault('stereo_w', 0.0)\n        kw.setdefault('enable_reverb', False)\n        super().__init__(intensity=0.8, duration=1.01, **kw)\n\n        # bit-crusher params\n        self.bit_depth = 6\n        self.sr_scale = 0.0\n\n        # comb-style delay params (delay + feedback)\n        self.comb_delay = 0.04\n        self.comb_feedback = 0.0\n        self.crossfade = 0.01\n\n        # cleanup filter\n        self.hpf_freq = 138.93\n\n        # envelope params\n        self.fade_in = 0.001\n        self.fade_out = 0.02\n\n        # storage for the signal chain\n        self.chain = {}\n\n    def _build(self):\n        # 1) click envelope\n        env = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity\n        ).play()\n\n        # 2) white-noise click\n        noise = Noise(mul=env)\n\n        # 3) bit-crusher\n        crushed = Degrade(noise,\n                          bitdepth=self.bit_depth,\n                          srscale=self.sr_scale)\n\n        # 4) comb-style delay via SmoothDelay (delay + feedback) :contentReference[oaicite:1]{index=1}\n        combed = SmoothDelay(crushed,\n                             delay=self.comb_delay,\n                             feedback=self.comb_feedback,\n                             crossfade=0.01)\n\n        # 5) high-pass cleanup\n        cleaned = ButHP(combed, freq=self.hpf_freq)\n\n        self.chain = {\n            \"env\": env,\n            \"crushed\": crushed,\n            \"combed\": combed,\n            \"cleaned\": cleaned\n        }\n        return cleaned\n\n    def play(self):\n        out = self._build()\n        out.out()\n        return self.chain\n\nif __name__ == \"__main__\":\n    DigitalSnap().play()\n"
        },
        {
            "file_path": "core/audio/presets/drone.py",
            "content": "# File: core/audio/presets/drone.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\nfrom pyo import Fader, Sine, SigTo\nfrom core.audio.presets.base_preset import BasePreset\n\nclass DronePreset(BasePreset):\n    \"\"\"Continuous drone whose level & pitch track settled_ratio & visual_metric.\"\"\"\n    def __init__(self, *, settled_ratio: float = 0.0, visual_metric: float = 0.0,fade_in=0.5,fade_out=0.1,dur=0.89):\n        super().__init__()  # uses default intensity/duration\n        self.settled_ratio = 0.0\n        self.visual_metric = 0.0\n        self.fade_in=0.5\n        self.fade_out=0.1\n        self.dur=0.89\n    def play(self):\n        env  = Fader(fadein=self.fade_in, fadeout=self.fade_out, dur=0.89, mul=self.settled_ratio).play()\n        freq = SigTo(value=200 + self.visual_metric * 800, time=0.1)\n        return Sine(freq=freq, mul=env * 0.3).out()\n    def _build(self):\n        # one-liner envelope \u00d7 drone\n        env = Fader(fadein=self.fade_in, fadeout=self.fade_out, dur=0.89, mul=self.intensity).play()\n        freq = SigTo(value=200 + self.visual_metric * 800, time=0.1)\n        return Sine(freq=freq, mul=env * 0.3)"
        },
        {
            "file_path": "core/audio/presets/fm_bell_cluster.py",
            "content": "# File: src/core/audio/presets/fm_bell_cluster.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nFMBellCluster \u2013 FM-based bell cluster with feedback, chorus and reverb.\n\"\"\"\n\nfrom pyo import FM, Chorus, Freeverb, Fader\nfrom core.audio.presets.base_preset import BasePreset\n\nclass FMBellCluster(BasePreset):\n    def __init__(\n        self,\n        intensity=0.6,\n        duration=4.0,\n        carrier_freq=330.0,\n        mod_ratio=2.0,\n        index=5.0,\n        chorus_depth=1.2,\n        chorus_feedback=0.3,\n        reverb_size=0.8,\n        reverb_bal=0.4,\n        fade_in=0.01,\n        fade_out=1.0,\n        **kw\n    ):\n        kw.setdefault('enable_reverb', True)\n        kw.setdefault('stereo_w', 0.2)\n        super().__init__(intensity=intensity, duration=duration, **kw)\n\n        # FM params\n        self.carrier_freq = carrier_freq\n        self.mod_ratio = mod_ratio\n        self.index = index\n\n        # chorus\n        self.chorus_depth = chorus_depth\n        self.chorus_feedback = chorus_feedback\n\n        # reverb\n        self.reverb_size = reverb_size\n        self.reverb_bal = reverb_bal\n\n        # envelope\n        self.fade_in = fade_in\n        self.fade_out = fade_out\n\n    def _build(self):\n        env = Fader(fadein=self.fade_in, fadeout=self.fade_out,\n                    dur=self.duration, mul=self.intensity).play()\n        # FM carrier/modulator\n        bell = FM(carrier=self.carrier_freq,\n                  ratio=self.mod_ratio,\n                  index=self.index,\n                  mul=env)\n        # add richness\n        ch = Chorus(bell, depth=self.chorus_depth,\n                    feedback=self.chorus_feedback)\n        # space\n        rv = Freeverb(ch, size=self.reverb_size,\n                      bal=self.reverb_bal)\n        self.chain = {\"env\": env, \"bell\": bell, \"chorus\": ch, \"reverb\": rv}\n        return rv\n\n    def play(self):\n        out = self._build()\n        out.out()\n        return self.chain\n"
        },
        {
            "file_path": "core/audio/presets/guitar.py",
            "content": "# File: src/core/audio/presets/guitar.py \u00a9 2025 projectemergence. All rights reserved.\n# Simulates a plucked sine loop guitar. _build() added for architecture support.\n\nfrom pyo import SineLoop, Fader, Chorus\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Guitar(BasePreset):\n    def __init__(\n        self,\n        intensity=1.0,\n        duration=0.18,\n        base_freq=220.0,\n        fade_in=0.01,\n        fade_out=0.36,\n        fader_mul_factor=0.57,\n        loop_feedback=0.07,\n        chorus_depth=0.44,\n        chorus_feedback=0.14,\n        chorus_bal=0.14,\n    ):\n        super().__init__(intensity, duration)\n        # core\n        self.base_freq = 220.0\n        # fader settings\n        self.fade_in = 0.01\n        self.fade_out = 0.36\n        self.fader_mul_factor = 0.57\n        # sine-loop settings\n        self.loop_feedback = 0.07\n        # chorus settings\n        self.chorus_depth = 0.44\n        self.chorus_feedback = 0.14\n        self.chorus_bal = 0.14\n\n    def _build(self):\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        tone = SineLoop(\n            freq=self.base_freq,\n            feedback=self.loop_feedback,\n            mul=fader\n        )\n        chorus = Chorus(\n            tone,\n            depth=self.chorus_depth,\n            feedback=self.chorus_feedback,\n            bal=self.chorus_bal\n        )\n        self.chain = {\"fader\": fader, \"tone\": tone, \"chorus\": chorus}\n        return self.chain\n\n    def play(self):\n        chain = self._build()\n        chain[\"fader\"].play()\n        chain[\"chorus\"].out()\n        return chain\n"
        },
        {
            "file_path": "core/audio/presets/harmonic_swarm.py",
            "content": "# File: src/core/audio/presets/harmonic_swarm.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nHarmonicSwarm \u2013 multiple detuned partials with dynamic panning and delay feedback.\n\"\"\"\n\nfrom random import uniform\nfrom pyo import Sine, Fader, Delay, Pan, Sine as LFO\nfrom core.audio.presets.base_preset import BasePreset\n\nclass HarmonicSwarm(BasePreset):\n    def __init__(\n        self,\n        intensity=0.04,\n        duration=4.7,   \n        base_freq=110.0,\n        num_voices=6,\n        freq_ratio=1.01,\n        pan_rate=0.05,\n        pan_depth=1.0,\n        delay_times=(0.1,0.2,0.3),\n        delay_feedback=0.3,\n        delay_mul=0.4,\n        fade_in=0.005,\n        fade_out=0.01,\n        **kw\n    ):\n        kw.setdefault('enable_reverb', True)\n        kw.setdefault('stereo_w', 0.3)\n        if duration==0:\n            duration=1\n        super().__init__(intensity=0.04, duration=4.7, **kw)\n\n        # core\n        self.base_freq = 110.0\n        self.num_voices = 6\n        self.freq_ratio = 1.01\n\n        # panning LFO\n        self.pan_rate = 0.05\n        self.pan_depth = 1.0\n\n        # delay\n        self.delay_times = delay_times\n        self.delay_feedback = 0.3\n        self.delay_mul = 0.4\n\n        # envelope\n        self.fade_in = 0.005\n        self.fade_out = 0.01\n\n    def _build(self):\n        # long fade for smooth crossfade\n        gate = Fader(fadein=self.fade_in, fadeout=self.fade_out,\n                     dur=self.duration, mul=self.intensity).play()\n\n        # create voices\n        voices = []\n        for i in range(self.num_voices):\n            detune = self.base_freq * (self.freq_ratio**i)\n            osc = Sine(freq=detune, mul=gate/self.num_voices)\n            pan_lfo = LFO(freq=self.pan_rate + uniform(-0.01,0.01),\n                          mul=self.pan_depth/2, add=0.5)\n            voices.append(Pan(osc, pan=pan_lfo))\n\n        mix = sum(voices)\n        # build one Delay per tap time and sum them\n        delays = []\n        for dt in self.delay_times:\n            delays.append(Delay(mix,\n                                delay=dt,\n                                feedback=self.delay_feedback,\n                                mul=self.delay_mul))\n        delayed = sum(delays)\n        self.chain = {\"gate\": gate, \"voices\": voices, \"delayed\": delayed}\n        return delayed\n\n    def play(self):\n        out = self._build()\n        out.out()\n        return self.chain\n"
        },
        {
            "file_path": "core/audio/presets/hi_hat.py",
            "content": "# File: src/core/audio/presets/hi_hat.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nFile: audio/presets/hi_hat.py\n\u00a9 2025 projectemergence. All rights reserved.\n\nDefines the Hi-Hat preset.\nSimulates a hi-hat using filtered noise with a short burst envelope.\nAdoptez une vision tourn\u00e9e vers l\u2019avenir!\n\"\"\"\n\nfrom pyo import Noise, Fader, ButHP\nfrom core.audio.presets.base_preset import BasePreset\n\nclass HiHat(BasePreset):\n    def __init__(\n        self,\n        intensity=0.76,\n        duration=1.85,\n        cutoff=5654.76,\n        fade_in=0.005,\n        fade_out=0.21,\n        fader_mul_factor=0.0,\n        **kw\n    ):\n        kw.setdefault('stereo_w', 0.0)\n        kw.setdefault('enable_reverb', False)\n        super().__init__(intensity=0.76, duration=1.85, **kw)\n        # filter cutoff\n        self.cutoff = 5654.76\n        # envelope settings\n        self.fade_in = 0.005\n        self.fade_out = 0.21\n        self.fader_mul_factor = 0.0\n\n    def _build(self):\n        # short burst envelope\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        noise = Noise(mul=fader)\n        hi_hat = ButHP(noise, freq=self.cutoff)\n        self.chain = {\"fader\": fader, \"noise\": noise, \"hi_hat\": hi_hat}\n        return self.chain\n\n    def play(self):\n        chain = self._build()\n        chain[\"fader\"].play()\n        chain[\"hi_hat\"].out()\n        return chain\n\nif __name__ == \"__main__\":\n    HiHat().play()\n"
        },
        {
            "file_path": "core/audio/presets/laser.py",
            "content": "# File: src/core/audio/presets/laser.py \u00a9 2025 projectemergence. All rights reserved.\n# Futuristic laser sound with FM. _build() added for architecture support.\n\nfrom pyo import Sine, Fader\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Laser(BasePreset):\n    def __init__(\n        self,\n        intensity=0.9,\n        duration=0.5,\n        base_freq=800.0,\n        mod_depth=50.0,\n        mod_rate=20.0,\n        fade_in=0.00,\n        fade_out=0.2,\n        fader_mul_factor=1.0,\n    ):\n        super().__init__(intensity, duration)\n        # core\n        self.base_freq = base_freq\n        self.mod_depth = mod_depth\n        self.mod_rate = mod_rate\n        # envelope settings\n        self.fade_in = fade_in\n        self.fade_out = fade_out\n        self.fader_mul_factor = fader_mul_factor\n\n    def _build(self):\n        # amplitude envelope\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        # modulator oscillator\n        mod = Sine(freq=self.mod_rate, mul=self.mod_depth)\n        # frequency-modulated carrier\n        modulated_freq = self.base_freq + mod\n        laser = Sine(freq=modulated_freq, mul=fader)\n        self.chain = {\"fader\": fader, \"mod\": mod, \"laser\": laser}\n        return self.chain\n\n    def play(self):\n        chain = self._build()\n        chain[\"fader\"].play()\n        chain[\"laser\"].out()\n        return chain\n"
        },
        {
            "file_path": "core/audio/presets/metallic_rain.py",
            "content": "# File: audio/presets/metallic_rain.py \u00a9 2025 projectemergence. All rights reserved.\n# \u00a9 2025 projectemergence\n#!/usr/bin/env python3\n\"\"\"\nMetallicRain \u2013 spectral drizzle with stereo drift and tail.\n(Fixed kw duplication 2025-04-23.)\n\"\"\"\n\nimport random, time, threading\nfrom pyo import Noise, ButBP, Sine, Fader, Mix\nfrom core.audio.presets.base_preset import BasePreset\n\nclass MetallicRain(BasePreset):\n    def __init__(\n        self,\n        intensity=0.4,\n        duration=6.0,\n        grain_rate=7,\n        base_freq=432.0,\n        width=0.9,\n        fade_env=0.2,\n        hiss_mul_factor=0.1,\n        hiss_freq_ratio=1.2,\n        hiss_q=0.2,\n        sweep_start_ratio=1.8,\n        sweep_end_ratio=0.4,\n        sweep_dur=0.4,\n        drop_rand_min=0.1,\n        drop_rand_max=2.4,\n        amp_rand_min=0.3,\n        amp_rand_max=0.7,\n        rate_rand_min=0.1,\n        rate_rand_max=2.0,\n        grain_bp_ratio=1.1,\n        grain_bp_q=8.0,\n        mix_voices=2,\n        **kw\n    ):\n        kw.setdefault('stereo_w', width)\n        kw.setdefault('enable_reverb', True)\n        super().__init__(intensity=intensity, duration=duration, **kw)\n\n        # core parameters\n        self.grain_rate = grain_rate\n        self.base_freq = base_freq\n\n        # envelope / hiss\n        self.fade_env = fade_env\n        self.hiss_mul_factor = hiss_mul_factor\n        self.hiss_freq_ratio = hiss_freq_ratio\n        self.hiss_q = hiss_q\n\n        # sweep (body) parameters\n        self.sweep_start_ratio = sweep_start_ratio\n        self.sweep_end_ratio = sweep_end_ratio\n        self.sweep_dur = sweep_dur\n\n        # randomization ranges\n        self.drop_rand_min = drop_rand_min\n        self.drop_rand_max = drop_rand_max\n        self.amp_rand_min = amp_rand_min\n        self.amp_rand_max = amp_rand_max\n        self.rate_rand_min = rate_rand_min\n        self.rate_rand_max = rate_rand_max\n\n        # grain filter\n        self.grain_bp_ratio = grain_bp_ratio\n        self.grain_bp_q = grain_bp_q\n\n        # final mix\n        self.mix_voices = mix_voices\n\n    def _grain(self, freq, dur, amp):\n        \"\"\"Create one grain: band-passed sine burst, auto-out.\"\"\"\n        grain = ButBP(\n            Sine(freq=freq),\n            freq=freq * self.grain_bp_ratio,\n            q=self.grain_bp_q,\n            mul=amp\n        )\n        grain.out()\n        return grain\n\n    def _build(self):\n        # create shared envelope for hiss and grains\n        fade = self._env(self.fade_env)\n\n        # hiss floor\n        hiss = ButBP(\n            Noise(mul=fade * self.hiss_mul_factor),\n            freq=self.base_freq * self.hiss_freq_ratio,\n            q=self.hiss_q\n        )\n\n        # spawn grains in background\n        def rain_loop():\n            end_t = time.time() + (self.duration or 1e9)\n            while time.time() < end_t:\n                drop = self.base_freq * random.uniform(self.drop_rand_min, self.drop_rand_max)\n                glide = self._sweep(\n                    drop * self.sweep_start_ratio,\n                    drop * self.sweep_end_ratio,\n                    self.sweep_dur\n                )\n                dur = random.uniform(self.sweep_dur * 0.25, self.sweep_dur * 0.875)\n                amp = fade * random.uniform(self.amp_rand_min, self.amp_rand_max)\n                self._keep(self._grain(glide, dur, amp))\n               \n        threading.Thread(target=rain_loop, daemon=True).start()\n\n        # mix to stereo\n        mix = Mix([hiss], voices=self.mix_voices)\n        self.chain = {\"fade\": fade, \"hiss\": hiss, \"mix\": mix}\n        return mix\n\n    def play(self):\n        mix = self._build()\n        mix.out()\n        return self.chain\n\nif __name__ == \"__main__\":\n    MetallicRain().play()\n"
        },
        {
            "file_path": "core/audio/presets/piano.py",
            "content": "#File:  audio/presets/piano.py \u00a9 2025 projectemergence. All rights reserved.\n# File: src/core/audio/presets/piano.py \u00a9 2025 projectemergence\n\nfrom pyo import Sine, Fader\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Piano(BasePreset):\n    def __init__(\n        self,\n        notes,\n        durations,\n        intensity=0.8,\n        fade_in=0.01,\n        fade_out=0.15,\n        fader_mul_factor=1.0,\n    ):\n        super().__init__(intensity, duration=None)\n        self.notes = notes\n        self.durations = durations\n        self.fade_in = fade_in\n        self.fade_out = fade_out\n        self.fader_mul_factor = fader_mul_factor\n\n    def _build(self):\n        seq = []\n        for note, dur in zip(self.notes, self.durations):\n            f = Fader(fadein=self.fade_in,\n                      fadeout=self.fade_out,\n                      dur=dur,\n                      mul=self.intensity * self.fader_mul_factor)\n            s = Sine(freq=note, mul=f)\n            seq.append((f, s))\n        return seq\n"
        },
        {
            "file_path": "core/audio/presets/reverse_impact.py",
            "content": "# File: src/core/audio/presets/reverse_impact.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nReverseImpact \u2013 swells that reverse-decay into impacts.\n\"\"\"\n\nfrom pyo import Noise, Fader, NewTable, TableRec, TableRead, ButBP, Disto\nfrom core.audio.presets.base_preset import BasePreset\n\nclass ReverseImpact(BasePreset):\n    def __init__(\n        self,\n        intensity=0.43,\n        duration=4.23,\n        env_dur=2.2,\n        bp_freq=800.0,\n        bp_q=5.0,\n        dist_drive=0.65,\n        dist_slope=0.39,\n        fade_in=0.07,\n        fade_out=0.41,\n        **kw\n    ):\n        super().__init__(intensity=0.43, duration=4.23, **kw)\n\n        # envelope recording length\n        self.env_dur = 2.2\n        self.fade_in = 0.07\n        self.fade_out = 0.41\n\n        # bandpass\n        self.bp_freq = 800.0\n        self.bp_q = 5.0\n\n        # distortion\n        self.dist_drive = 0.65\n        self.dist_slope = 0.39\n\n    def _build(self):\n        # create reversed envelope table\n        tbl = NewTable(length=self.env_dur)\n        env = Fader(fadein=self.env_dur, fadeout=0,\n                    dur=self.env_dur, mul=self.intensity).play()\n        # record noise burst\n        rec = TableRec(Noise(mul=env), table=tbl).play()\n\n        # read it *backwards*\n        reader = TableRead(\n            table=tbl,\n            freq=-tbl.getRate(),  \n                         \n            mul=1.0\n        )\n\n        # then the rest of your chain\n        filtered  = ButBP(reader, freq=self.bp_freq, q=self.bp_q)\n        distorted = Disto(filtered,\n                          drive=self.dist_drive,\n                          slope=self.dist_slope,\n                          mul=1.0)\n\n        self.chain = {\n            \"env\": env,\n            \"rec\": rec,\n            \"reader\": reader,\n            \"filtered\": filtered,\n            \"distorted\": distorted\n        }\n        return distorted\n\n\n    def play(self):\n        out = self._build()\n        out.out()\n        return self.chain\n"
        },
        {
            "file_path": "core/audio/presets/snare.py",
            "content": "# File: src/core/audio/presets/snare.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nFile: audio/presets/snare.py\n\u00a9 2025 projectemergence. All rights reserved.\n\nDefines the Snare preset.\nSimulates a snare drum using a short burst of noise filtered with a narrow bandpass.\nAdoptez une vision tourn\u00e9e vers l\u2019avenir!\n\"\"\"\n\nfrom pyo import Noise, Fader, ButBP\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Snare(BasePreset):\n    def __init__(\n        self,\n        intensity=0.64,\n        duration=0.54,\n        center_freq=19.952623149688797,\n        fade_in=0.01,\n        fade_out=0.2,\n        fader_mul_factor=1.0,\n        **kw\n    ):\n        # ensure stereo and reverb defaults\n        kw.setdefault('stereo_w', 0.0)\n        kw.setdefault('enable_reverb', False)\n        super().__init__(intensity=0.64, duration=0.54, **kw)\n\n        # filter center frequency\n        self.center_freq = 19.952623149688797\n\n        # envelope settings\n        self.fade_in = 0.01\n        self.fade_out = 0.2\n        self.fader_mul_factor = 1.0\n\n        # storage for built objects\n        self.chain = {}\n\n    def _build(self):\n        # create the burst envelope\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        # noise source\n        noise = Noise(mul=fader)\n        # band-pass filter for snare character\n        snare = ButBP(noise, freq=self.center_freq)\n\n        self.chain = {\"fader\": fader, \"noise\": noise, \"snare\": snare}\n        return snare\n\n    def play(self):\n        snare = self._build()\n        # start envelope and output\n        self.chain[\"fader\"].play()\n        snare.out()\n        return self.chain\n\nif __name__ == \"__main__\":\n    Snare().play()\n"
        },
        {
            "file_path": "core/audio/presets/square_fall.py",
            "content": "# File: core/audio/presets/square_fall.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\nfrom pyo import Fader, Sine, IRPulse\nfrom core.audio.presets.base_preset import BasePreset\n\nclass SquareFallPreset(BasePreset):\n    \"\"\"Burst of harmonics into a comb filter (square-fall).\"\"\"\n    def __init__(self, *, intensity: float = 0.5, freq: float = 200, harmonics: int = 6):\n        super().__init__()\n        self.intensity = intensity\n        self.freq      = freq\n        self.harmonics = harmonics\n\n    def play(self):\n        env   = Fader(fadein=0.01, fadeout=0.25, dur=0.25, mul=self.intensity).play()\n        burst = sum(Sine(freq=self.freq * (i+1), mul=env / (i+1))\n                    for i in range(self.harmonics))\n        IRPulse(input=burst, order=2048).out()\n        return burst\n    def _build(self):\n        # envelope & additive burst\n        env = Fader(fadein=0.01, fadeout=0.25, dur=0.25, mul=self.intensity).play()\n        burst = sum(\n            Sine(freq=self.freq * (i + 1), mul=env / (i + 1))\n            for i in range(self.harmonics)\n        )\n        IRPulse(input=burst, order=2048).out()\n        return burst"
        },
        {
            "file_path": "core/audio/presets/trumpet.py",
            "content": "# File: src/core/audio/presets/trumpet.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nFile: audio/presets/trumpet.py\n\u00a9 2025 projectemergence. All rights reserved.\n\nDefines the Trumpet preset.\nEmulates a bright brass sound with a characteristically brassy vibrato and warm filtering.\nAdoptez une vision tourn\u00e9e vers l\u2019avenir!\n\"\"\"\n\nfrom pyo import Sine, Fader, Chorus, ButLP, SigTo\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Trumpet(BasePreset):\n    def __init__(\n        self,\n        intensity=0.8,\n        duration=1.5,\n        base_freq=440.0,\n        vibrato_rate=6.0,\n        vibrato_depth=10.0,\n        fade_in=0.05,\n        fade_out=0.7,\n        fader_mul_factor=1.0,\n        sigto_time_factor=1.0,\n        lp_freq=1000.0,\n        chorus_depth=1.0,\n        chorus_feedback=0.25,\n        chorus_bal=0.5,\n        **kw\n    ):\n        kw.setdefault('stereo_w', 0.0)\n        kw.setdefault('enable_reverb', False)\n        super().__init__(intensity=intensity, duration=duration, **kw)\n\n        # core tone parameters\n        self.base_freq = base_freq\n        self.vibrato_rate = vibrato_rate\n        self.vibrato_depth = vibrato_depth\n\n        # envelope settings\n        self.fade_in = fade_in\n        self.fade_out = fade_out\n        self.fader_mul_factor = fader_mul_factor\n\n        # SigTo (smooth freq) timing\n        self.sigto_time_factor = sigto_time_factor\n\n        # filtering\n        self.lp_freq = lp_freq\n\n        # chorus effect\n        self.chorus_depth = chorus_depth\n        self.chorus_feedback = chorus_feedback\n        self.chorus_bal = chorus_bal\n\n    def _build(self):\n        # amplitude envelope\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        # smooth base frequency holder\n        freq_mod = SigTo(\n            value=self.base_freq,\n            time=self.duration * self.sigto_time_factor\n        )\n        # vibrato oscillator\n        vibrato = Sine(freq=self.vibrato_rate, mul=self.vibrato_depth)\n        # combine base freq and vibrato\n        modulated_freq = freq_mod + vibrato\n        # carrier tone\n        tone = Sine(freq=modulated_freq, mul=fader)\n        # warm low-pass filter\n        filtered = ButLP(tone, freq=self.lp_freq)\n        # richness via chorus\n        chorus = Chorus(\n            filtered,\n            depth=self.chorus_depth,\n            feedback=self.chorus_feedback,\n            bal=self.chorus_bal\n        )\n\n        self.chain = {\n            \"fader\": fader,\n            \"freq_mod\": freq_mod,\n            \"vibrato\": vibrato,\n            \"tone\": tone,\n            \"filtered\": filtered,\n            \"chorus\": chorus\n        }\n        return chorus\n\n    def play(self):\n        out = self._build()\n        self.chain[\"fader\"].play()\n        out.out()\n        return self.chain\n\nif __name__ == \"__main__\":\n    Trumpet().play()\n"
        },
        {
            "file_path": "core/audio/presets/two_freq_drones.py",
            "content": "# File: src/core/audio/presets/two_freq_drones.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n# \u00a9 2025 projectemergence\n\n\"\"\"\nTwoFreqDrones \u2013 subtle, continuously-evolving dual-sine drone.\n\u2022 Always-on; no need to reschedule-loop.\n\u2022 Slow random drift on both oscillators via band-limited LFO.\n\u2022 Dual Faders give click-free start/stop and enable cross-fade\n  when the engine really has to restart the preset.\n\"\"\"\n\nfrom random import random\nfrom pyo import Sine, Fader, Sine as LFO\nfrom core.audio.presets.base_preset import BasePreset   # unchanged\n\nclass TwoFreqDrones(BasePreset):\n    def __init__(\n        self,\n        base_freq=65.4,\n        ratio=4/3,\n        drift_speed=0.04,\n        intensity=0.5,\n        fade=2.0,\n        drift_mul_ratio=0.015,\n        osc_amp_factor=0.5,\n        mix_voices=2,\n        **kw\n    ):\n        kw.setdefault('enable_reverb', True)\n        kw.setdefault('stereo_w', 0.3)\n        # duration=0 => infinite\n        super().__init__(intensity=intensity, duration=0, **kw)\n\n        # core parameters\n        self.base_freq = base_freq\n        self.ratio = ratio\n\n        # drift LFO\n        self.drift_speed = drift_speed\n        self.drift_mul_ratio = drift_mul_ratio\n\n        # cross-fade gate\n        self.fade = fade\n\n        # oscillator amplitude relative to gate\n        self.osc_amp_factor = osc_amp_factor\n\n        # mixing\n        self.mix_voices = mix_voices\n\n    def _drifting_osc(self, freq, amp):\n        \"\"\"Band-limited LFO to drift the oscillator frequency \u00b1drift_mul_ratio.\"\"\"\n        drift = LFO(\n            freq=self.drift_speed,\n            phase=random(),\n            mul=freq * self.drift_mul_ratio,\n            add=freq\n        )\n        return Sine(freq=drift, mul=amp)\n\n    def _build(self):\n        # gate fader for crossfade\n        gate = Fader(\n            fadein=self.fade,\n            fadeout=self.fade,\n            dur=self.duration,\n            mul=self.intensity\n        ).play()\n\n        # two drifting oscillators\n        osc_a = self._drifting_osc(self.base_freq, gate * self.osc_amp_factor)\n        osc_b = self._drifting_osc(self.base_freq * self.ratio, gate * self.osc_amp_factor)\n\n        # mix to stereo voices\n        mix = (osc_a + osc_b).mix(self.mix_voices)\n\n        # store chain\n        self.chain = {\"gate\": gate, \"osc_a\": osc_a, \"osc_b\": osc_b, \"mix\": mix}\n        return mix\n\n    def play(self):\n        out = self._build()\n        out.out()\n        return self.chain\n\nif __name__ == \"__main__\":\n    TwoFreqDrones().play()"
        },
        {
            "file_path": "core/audio/presets/violin.py",
            "content": "# File: src/core/audio/presets/violin.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nFile: audio/presets/violin.py\n\u00a9 2025 projectemergence. All rights reserved.\n\nDefines the Violin preset.\nSimulates a bowed string instrument using a sine oscillator with vibrato.\nAdoptez une vision tourn\u00e9e vers l\u2019avenir!\n\"\"\"\n\nfrom pyo import Sine, Fader\nfrom core.audio.presets.base_preset import BasePreset\n\nclass Violin(BasePreset):\n    def __init__(\n        self,\n        intensity=0.5,\n        duration=3.0,\n        base_freq=4063.57,\n        vibrato_rate=5.0,\n        vibrato_depth=5.0,\n        fade_in=0.1,\n        fade_out=0.5,\n        fader_mul_factor=0.46,\n    ):\n        super().__init__(intensity, duration)\n        # core tone params\n        self.base_freq = 4063.57\n        self.vibrato_rate = 5.0\n        self.vibrato_depth = 5.0\n        # envelope params\n        self.fade_in = 0.1\n        self.fade_out = 0.5\n        self.fader_mul_factor = 0.46\n        # storage for chain\n        self.chain = {}\n\n    def _build(self):\n        # amplitude envelope\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        # vibrato LFO\n        vibrato = Sine(freq=self.vibrato_rate, mul=self.vibrato_depth)\n        # modulated carrier\n        modulated_freq = self.base_freq + vibrato\n        tone = Sine(freq=modulated_freq, mul=fader)\n        self.chain = {\"fader\": fader, \"vibrato\": vibrato, \"tone\": tone}\n        return self.chain\n\n    def play(self):\n        chain = self._build()\n        chain[\"fader\"].play()\n        chain[\"tone\"].out()\n        return chain\n\nif __name__ == \"__main__\":\n    Violin().play()"
        },
        {
            "file_path": "core/audio/presets/whale_calls.py",
            "content": "# File: src/core/audio/presets/whale_calls.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nFile: audio/presets/whale_calls.py\n\u00a9 2025 projectemergence. All rights reserved.\n\nDefines the WhaleCalls preset class.\nProvides a low\u2013frequency whale call preset.\n\nAdoptez une vision tourn\u00e9e vers l\u2019avenir!\n\"\"\"\n\nfrom pyo import Sine, Fader\nfrom core.audio.presets.base_preset import BasePreset\n\nclass WhaleCalls(BasePreset):\n    def __init__(\n        self,\n        intensity=0.4,\n        duration=4.0,\n        freq=110.0,\n        fade_in=1.0,\n        fade_out=1.0,\n        fader_mul_factor=1.0,\n        **kw\n    ):\n        kw.setdefault('stereo_w', 0.0)\n        kw.setdefault('enable_reverb', False)\n        super().__init__(intensity=intensity, duration=duration, **kw)\n        # core frequency\n        self.freq = freq\n        # envelope settings\n        self.fade_in = fade_in\n        self.fade_out = fade_out\n        self.fader_mul_factor = fader_mul_factor\n        # storage for chain\n        self.chain = {}\n\n    def _build(self):\n        # amplitude envelope\n        fader = Fader(\n            fadein=self.fade_in,\n            fadeout=self.fade_out,\n            dur=self.duration,\n            mul=self.intensity * self.fader_mul_factor\n        )\n        # carrier sine for whale call\n        sine = Sine(freq=self.freq, mul=fader)\n        self.chain = {\"fader\": fader, \"sine\": sine}\n        return sine\n\n    def play(self):\n        sine = self._build()\n        self.chain[\"fader\"].play()\n        sine.out()\n        return self.chain\n\nif __name__ == \"__main__\":\n    WhaleCalls().play()\n"
        },
        {
            "file_path": "core/audio/presets/wood_kick.py",
            "content": "# File: src/core/audio/presets/wood_kick.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n# \u00a9 2025 projectemergence. All rights reserved.\n\n\"\"\"\nWoodKick \u2013 a clean, wooden-character kick with minimal noise.\nTechnique enhancements:\n \u2022 body: sine sweep (45\u2192400 Hz) with high-pass DC removal\n \u2022 click: band-limited noise burst with high-pass cleanup\n \u2022 separate multi-stage envelopes for tight attack & body\n \u2022 gentle tanh saturation with pre-filter antialiasing\n\"\"\"\n\nfrom pyo import Sine, Noise, ButBP, ButHP, Biquad, Fader, SigTo, Tanh\nfrom core.audio.presets.base_preset import BasePreset\n\nclass WoodKick(BasePreset):\n    def __init__(\n        self,\n        intensity=0.3,\n        duration=0.36,\n        click_freq=1200.0,\n        hp_cut=200.0,\n        body_sweep_ratio=0.8,\n        body_mul_factor=1.9,\n        body_hpf_freq=20.0,\n        body_hpf_q=0.707,\n        body_hpf_type=2,\n        click_env_fadein=0.0005,\n        click_env_fadeout=0.05,\n        click_env_dur=0.05,\n        click_mul_factor=2.0,\n        click_bp_q=55.0,\n        sat_mul=1.5,\n        sat_hpf_freq=200.0,\n        sat_hpf_q=0.307,\n        sat_hpf_type=2,\n        **kw\n    ):\n        kw.setdefault('stereo_w', 0.0)\n        kw.setdefault('enable_reverb', False)\n        super().__init__(\n            intensity=2 * intensity,\n            duration=duration,\n            freq1=45.0,\n            freq2=400.0,\n            **kw\n        )\n        # click\n        self.click_freq = click_freq\n        self.hp_cut = hp_cut\n        # body\n        self.body_sweep_ratio = body_sweep_ratio\n        self.body_mul_factor = body_mul_factor\n        self.body_hpf_freq = body_hpf_freq\n        self.body_hpf_q = body_hpf_q\n        self.body_hpf_type = body_hpf_type\n        # click envelope\n        self.click_env_fadein = click_env_fadein\n        self.click_env_fadeout = click_env_fadeout\n        self.click_env_dur = click_env_dur\n        self.click_mul_factor = click_mul_factor\n        self.click_bp_q = click_bp_q\n        # saturation\n        self.sat_mul = sat_mul\n        self.sat_hpf_freq = sat_hpf_freq\n        self.sat_hpf_q = sat_hpf_q\n        self.sat_hpf_type = sat_hpf_type\n\n    def _body(self, env):\n        glide = self._sweep(\n            self.freq1,\n            self.freq2,\n            self.duration * self.body_sweep_ratio,\n            exp=False\n        )\n        osc = Sine(freq=glide, mul=env * self.body_mul_factor)\n        return Biquad(\n            osc,\n            freq=self.body_hpf_freq,\n            q=self.body_hpf_q,\n            type=self.body_hpf_type\n        )\n\n    def _click(self):\n        env = Fader(\n            fadein=self.click_env_fadein,\n            fadeout=self.click_env_fadeout,\n            dur=self.click_env_dur,\n            mul=self.click_mul_factor * self.intensity\n        ).play()\n        noise = Noise(mul=env)\n        bp = ButBP(noise, freq=self.click_freq, q=self.click_bp_q)\n        return ButHP(bp, freq=self.hp_cut)\n\n    def _build(self):\n        env = self._env(.005)\n        mix = self._body(env) + self._click()\n        sat = Tanh(mix * self.sat_mul)\n        out = Biquad(\n            sat,\n            freq=self.sat_hpf_freq,\n            q=self.sat_hpf_q,\n            type=self.sat_hpf_type\n        )\n        self.chain = {\"body_env\": env, \"mix\": mix, \"out\": out}\n        return out\n\n    def play(self):\n        out = self._build()\n        # start body envelope\n        self.chain[\"body_env\"].play()\n        out.out()\n        return self.chain\n\nif __name__ == \"__main__\":\n    WoodKick().play()\n"
        },
        {
            "file_path": "core/audio/presets/__init__.py",
            "content": "#File:  src/core/audio/__init__.py \u00a9 2025 projectemergence. All rights reserved.\n#File:  src/core/__init__.py \u00a9 2024 projectemergence. All rights reserved.\n# This file can be left empty, or you can use it to perform package-level initialization if needed.\n"
        },
        {
            "file_path": "core/audio/speech/speech_manager.py",
            "content": "#File:  src/core/speech/speech_manager.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python3\n\"\"\"\nFile: src/core/speech/speech_audio_manager.py\n\u00a9 2024 projectemergence. All rights reserved.\n\nRevised version to fix the issue where speech only works once. This version creates a persistent\npyttsx3 engine (instead of reinitializing it per utterance) and adds a longer delay before removing\ntemporary audio files to ensure the pyo server has sufficient time to load them.\n\nAdoptez une vision tourn\u00e9e vers l\u2019avenir!\n\"\"\"\n\nimport pyttsx3\nimport queue\nimport random\nimport time\nimport os\nimport tempfile\nfrom threading import Thread\nfrom pyo import Server, SfPlayer, Harmonizer, Granulator, Freeverb, Disto, Degrade, Noise, ButLP\n\nclass SpeechManager:\n    def __init__(self, default_voice_id=None, default_rate=175, default_volume=1.0,\n                 sample_rate=44100, buffersize=512):\n        self.default_rate = default_rate\n        self.default_volume = default_volume\n        self.default_voice_id = default_voice_id\n\n        self.speech_queue = queue.Queue()\n\n        self.engine = pyttsx3.init()\n        self.engine.setProperty('rate', self.default_rate)\n        self.engine.setProperty('volume', self.default_volume)\n        if self.default_voice_id:\n            self.engine.setProperty('voice', self.default_voice_id)\n\n        self.tts_thread = Thread(target=self._run_tts_engine, daemon=True)\n        self.tts_thread.start()\n\n        self.server = Server(sr=sample_rate, buffersize=buffersize, nchnls=2).boot()\n        self.server.start()\n\n        self.current_player = None\n\n    def _determine_style(self, text, context):\n        if context.get(\"modem\", False):\n            return \"modem56k\"\n        if context.get(\"idle\", False):\n            return \"humming\"\n        word_count = len(text.split())\n        style = \"robot\" if word_count > 2 else \"short\"\n        if word_count >= 10:\n            style = \"long\"\n        if context.get(\"order_direction\", 1) < 0:\n            style = \"trembling\"\n        elif context.get(\"order_direction\", 1) > 0:\n            style = \"robot\"\n        if abs(context.get(\"global_angle\", 0)) > 1.0:\n            style = \"calabiyau\"\n        if context.get(\"frame_counter\", 0) % context.get(\"num_frames_per_transition\", 128) < 10:\n            style = \"robot\"\n        return style\n\n    def _transform_text_for_effects(self, text, style):\n        if style in [\"trembling\", \"long\", \"modem56k\"]:\n            return \" \".join(word[0] + \"-\" + word if len(word) > 3 and random.random() < 0.2 else word\n                            for word in text.split())\n        return text\n\n    def _apply_tts_style(self, engine, style, text):\n        voices = engine.getProperty('voices')\n        if style == \"robot\":\n            robot_voice = next((v.id for v in voices if \"robot\" in v.name.lower()), (voices[0].id if voices else None))\n            engine.setProperty('voice', robot_voice)\n            engine.setProperty('rate', 150)\n        elif style == \"short\":\n            engine.setProperty('voice', voices[0].id if voices else self.default_voice_id)\n            engine.setProperty('rate', 200)\n        elif style == \"long\":\n            engine.setProperty('voice', voices[0].id if voices else self.default_voice_id)\n            engine.setProperty('rate', 170)\n        elif style == \"calabiyau\":\n            engine.setProperty('voice', voices[0].id if voices else self.default_voice_id)\n            engine.setProperty('rate', 160)\n        elif style == \"trembling\":\n            engine.setProperty('voice', voices[0].id if voices else self.default_voice_id)\n            engine.setProperty('rate', 180)\n        elif style == \"repeat\":\n            engine.setProperty('voice', voices[0].id if voices else self.default_voice_id)\n            engine.setProperty('rate', 180)\n        elif style == \"humming\":\n            engine.setProperty('voice', voices[0].id if voices else self.default_voice_id)\n            engine.setProperty('rate', 90)\n            engine.setProperty('volume', 0.8)\n            text = \"\u266a mmm mmm mmm \u266a\"\n        elif style == \"modem56k\":\n            engine.setProperty('voice', voices[0].id if voices else self.default_voice_id)\n            engine.setProperty('rate', 140)\n            engine.setProperty('volume', 0.9)\n        else:\n            engine.setProperty('voice', self.default_voice_id if self.default_voice_id else (voices[0].id if voices else \"\"))\n            engine.setProperty('rate', self.default_rate)\n            engine.setProperty('volume', self.default_volume)\n        return text\n\n    def _safe_remove(self, filename, attempts=10, delay=0.5):\n        for _ in range(attempts):\n            try:\n                os.remove(filename)\n                return\n            except Exception:\n                time.sleep(delay)\n        print(f\"Warning: Could not remove temporary file {filename} after {attempts} attempts.\")\n\n    def _play_audio(self, filename, context):\n        if self.current_player is not None:\n            self.current_player.stop()\n        snd = SfPlayer(filename, speed=1, loop=False)\n        style = self._determine_style(\"\", context)\n        pitch_shift = 4 if context.get(\"global_angle\", 0) > 1.0 else -4 if context.get(\"global_angle\", 0) < -1.0 else 0\n        if pitch_shift:\n            snd = Harmonizer(snd, transpo=pitch_shift)\n        if context.get(\"idle\", False):\n            snd = Granulator(snd, grainSize=0.05, overlap=0.3, pitch=1.0, mul=0.8)\n        rev_amount = 0.3 if context.get(\"order_direction\", 1) > 0 else 0.7\n        proc = Freeverb(snd, size=rev_amount, bal=0.4)\n        if style == \"modem56k\":\n            proc = Disto(proc, drive=0.8, slope=0.5, mul=0.8)\n            proc = Degrade(proc, bitdepth=8, srscale=0.5)\n            proc = proc + Noise(mul=0.05)\n            proc = ButLP(proc, freq=3000)\n        self.current_player = proc\n        proc.out()\n        print(f\"Playing audio from {filename} with style '{style}'.\")\n\n    def _run_tts_engine(self):\n        while True:\n            try:\n                item = self.speech_queue.get(block=True)\n                if item is None:\n                    break\n                text, context = item\n                if text == \"__STOP__\":\n                    self.engine.stop()\n                    if self.current_player is not None:\n                        self.current_player.stop()\n                    continue\n                engine = self.engine\n                engine.setProperty('rate', self.default_rate)\n                engine.setProperty('volume', self.default_volume)\n                if self.default_voice_id:\n                    engine.setProperty('voice', self.default_voice_id)\n                style = self._determine_style(text, context)\n                text = self._transform_text_for_effects(text, style)\n                text = self._apply_tts_style(engine, style, text)\n                with tempfile.NamedTemporaryFile(suffix=\".wav\", delete=False) as tmp:\n                    temp_filename = tmp.name\n                engine.save_to_file(text, temp_filename)\n                engine.runAndWait()\n                self._play_audio(temp_filename, context)\n                time.sleep(0.5)\n                self._safe_remove(temp_filename)\n                print(f\"Utterance '{text}' processed.\")\n            except queue.Empty:\n                continue\n\n    def speak(self, text, context=None):\n        if context is None:\n            context = {}\n        self.speech_queue.put((text, context))\n        print(f\"Queued text: {text}\")\n\n    def stop_speaking(self):\n        try:\n            while True:\n                self.speech_queue.get_nowait()\n        except queue.Empty:\n            pass\n        self.speech_queue.put((\"__STOP__\", {}))\n        print(\"Stop command issued.\")\n\n    def shutdown(self):\n        self.speech_queue.put(None)\n        self.tts_thread.join(timeout=2)\n        self.server.stop()\n        self.server.shutdown()\n        print(\"Shutdown complete.\")\n"
        },
        {
            "file_path": "core/audio/speech/__init__.py",
            "content": "#File:  src/core/speech/__init__.py \u00a9 2025 projectemergence. All rights reserved.\n#File:  src/core/__init__.py \u00a9 2024 projectemergence. All rights reserved.\n# This file can be left empty, or you can use it to perform package-level initialization if needed.\n"
        },
        {
            "file_path": "performances/async_blob_manager.py",
            "content": "#File:  src/performances/async_blob_manager.py \u00a9 2025 projectemergence. All rights reserved.\n# File:  src/performances/async_blob_manager.py\nimport json\nimport asyncio\nimport aiohttp\nfrom async_hyper_manager import AsyncHyperManager\n\nJSONBLOB_BASE = \"https://jsonblob.com/api/jsonBlob\"\n\nclass AsyncBlobManager:\n    \"\"\"Async version of BlobManager, using aiohttp & AsyncHyperManager for pooling.\"\"\"\n\n    def __init__(self, blob_id: str | None = \"1294281086207909888\"):\n        self.blob_id = blob_id\n        self.base = f\"{JSONBLOB_BASE}/{blob_id}\" if blob_id else JSONBLOB_BASE\n        self._session: aiohttp.ClientSession | None = None\n        self._mgr = AsyncHyperManager(max_threads=10, max_processes=2)\n\n    async def _session(self) -> aiohttp.ClientSession:\n        if not self._session or self._session.closed:\n            self._session = aiohttp.ClientSession()\n        return self._session\n\n    async def create_blob(self, data: dict) -> str | None:\n        session = await self._session()\n        async with session.post(JSONBLOB_BASE, json=data) as resp:\n            if resp.status == 201:\n                loc = resp.headers.get(\"Location\", \"\")\n                self.blob_id = loc.rsplit(\"/\", 1)[-1]\n                self.base = f\"{JSONBLOB_BASE}/{self.blob_id}\"\n                return self.blob_id\n            return None\n\n    async def get_blob(self) -> dict | None:\n        if not self.blob_id:\n            return None\n        session = await self._session()\n        async with session.get(self.base) as resp:\n            return await resp.json() if resp.status == 200 else None\n\n    async def update_blob(self, data: dict) -> bool:\n        if not self.blob_id:\n            return False\n        session = await self._session()\n        async with session.put(self.base, json=data) as resp:\n            return resp.status == 200\n\n    async def delete_blob(self) -> bool:\n        if not self.blob_id:\n            return False\n        session = await self._session()\n        async with session.delete(self.base) as resp:\n            ok = resp.status == 200\n            if ok:\n                self.blob_id = None\n                self.base = JSONBLOB_BASE\n            return ok\n\n    async def close(self):\n        if self._session and not self._session.closed:\n            await self._session.close()\n        await self._mgr.shutdown()\n"
        },
        {
            "file_path": "performances/async_hyper_manager.py",
            "content": "# File: src/performances/async_hyper_manager.py \u00a9 2025 projectemergence. All rights reserved.\nimport os\nimport asyncio\nimport functools\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor\nfrom typing import Optional\n\nclass AsyncHyperManager:\n    \"\"\"\n    Async \u201chyper\u201d manager for tasks:\n      - pure coroutines run on the loop\n      - sync callables auto-offloaded to thread/process pools\n      - max concurrency via semaphore\n      - dynamic start/stop/list/cancel/await\n    \"\"\"\n    def __init__(self,\n                 *,\n                 max_threads: int | None = None,\n                 max_processes: int | None = None,\n                 loop: Optional[asyncio.AbstractEventLoop] = None,\n                 logger: logging.Logger | None = None):\n        # allow caller to supply a fresh loop\n        self.loop = loop or asyncio.get_event_loop()\n        self.logger = logger or logging.getLogger(__name__)\n        cpu = os.cpu_count() or 1\n        self.thread_executor  = ThreadPoolExecutor(max_threads or cpu)\n        self.process_executor = ProcessPoolExecutor(max_processes or cpu)\n        # bind our semaphore to this loop\n        self.semaphore = asyncio.Semaphore(max_threads or cpu)\n        self._tasks: dict[str, asyncio.Task] = {}\n        self._lock = asyncio.Lock()\n\n    async def schedule(self,\n                       name: str,\n                       fn: callable,\n                       *args,\n                       kind: str = \"thread\",\n                       **kwargs) -> None:\n        async with self._lock:\n            if name in self._tasks:\n                self.logger.warning(f\"Task '{name}' exists, skipping\")\n                return\n            await self.semaphore.acquire()\n            if asyncio.iscoroutinefunction(fn):\n                task = self.loop.create_task(self._runner(name, fn, *args, **kwargs))\n            else:\n                pool = self.thread_executor if kind == \"thread\" else self.process_executor\n                task = self.loop.create_task(\n                    self._runner(name,\n                                 lambda *a, **k: self.loop.run_in_executor(pool, functools.partial(fn, *a, **k)),\n                                 *args, **kwargs)\n                )\n            self._tasks[name] = task\n\n    async def _runner(self, name: str, coro_fn: callable, *args, **kwargs):\n        self.logger.info(f\"\u25b6 Starting '{name}'\")\n        try:\n            return await coro_fn(*args, **kwargs)\n        except asyncio.CancelledError:\n            self.logger.info(f\"\u2716 Cancelled '{name}'\")\n            raise\n        except Exception as e:\n            self.logger.exception(f\"\u203c Exception in '{name}': {e}\")\n        finally:\n            async with self._lock:\n                self._tasks.pop(name, None)\n                self.semaphore.release()\n                self.logger.info(f\"\u2714 Finished '{name}'\")\n\n    def list_tasks(self) -> list[str]:\n        return list(self._tasks.keys())\n\n    async def cancel(self, name: str) -> None:\n        async with self._lock:\n            t = self._tasks.get(name)\n            if t:\n                t.cancel()\n\n    async def wait(self, name: str) -> None:\n        t = self._tasks.get(name)\n        if t:\n            await t\n\n    async def shutdown(self) -> None:\n        \"\"\"Cancel & await all tasks, then tear down executors.\"\"\"\n        async with self._lock:\n            for t in self._tasks.values():\n                t.cancel()\n        await asyncio.gather(*self._tasks.values(), return_exceptions=True)\n        self.thread_executor.shutdown(wait=False)\n        self.process_executor.shutdown(wait=False)\n\n    def close(self):\n        \"\"\"\n        Synchronous cleanup:\n          1) run shutdown coroutine to cancel & wait tasks\n          2) stop the loop\n        \"\"\"\n        # 1) shutdown async tasks & executors\n        fut = asyncio.run_coroutine_threadsafe(self.shutdown(), self.loop)\n        fut.result()\n        # 2) stop the loop\n        self.loop.call_soon_threadsafe(self.loop.stop)\n"
        },
        {
            "file_path": "performances/blob.py",
            "content": "#File:  src/performances/blob.py \u00a9 2025 projectemergence. All rights reserved.\nimport os\nimport configparser\nimport requests\nimport json\n\n# Constants for JSON Blob\nJSONBLOB_API_URL = \"https://jsonblob.com/api/jsonBlob\"\n\nclass BlobManager:\n    \"\"\"Handles interactions with JSON Blob.\"\"\"\n\n    def __init__(self, blob_id=\"1294281086207909888\"):\n        \"\"\"\n        Initialize the BlobManager with an optional blob ID.\n        If no blob ID is provided, it can be set later.\n        \"\"\"\n        self.blob_id = blob_id\n        self.base_url = JSONBLOB_API_URL if not blob_id else f\"{JSONBLOB_API_URL}/{self.blob_id}\"\n\n    def create_blob(self, data):\n        \"\"\"\n        Create a new JSON Blob.\n\n        Args:\n            data (dict): The JSON data to store.\n\n        Returns:\n            str: The blob ID if creation is successful, else None.\n        \"\"\"\n        try:\n            response = requests.post(\n                JSONBLOB_API_URL,\n                headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n                data=json.dumps(data)\n            )\n            if response.status_code == 201:\n                location = response.headers.get('Location', '')\n                self.blob_id = location.split('/')[-1]\n                self.base_url = f\"{JSONBLOB_API_URL}/{self.blob_id}\"\n                print(f\"Blob created successfully with ID: {self.blob_id}\")\n                return self.blob_id\n            else:\n                print(f\"Error creating blob: {response.status_code} - {response.text}\")\n                return None\n        except Exception as e:\n            print(f\"Exception during POST: {e}\")\n            return None\n\n    def get_blob(self):\n        \"\"\"\n        Retrieve the current JSON Blob data.\n\n        Returns:\n            dict: The JSON data if retrieval is successful, else None.\n        \"\"\"\n        if not self.blob_id:\n            print(\"Blob ID is not set.\")\n            return None\n\n        try:\n            response = requests.get(\n                self.base_url,\n                headers={\"Accept\": \"application/json\"}\n            )\n            if response.status_code == 200:\n                #print(\"Blob retrieved successfully.\")\n                return response.json()\n            elif response.status_code == 404:\n                print(\"Blob not found.\")\n                return None\n            else:\n                print(f\"Error retrieving blob: {response.status_code} - {response.text}\")\n                return None\n        except Exception as e:\n            print(f\"Exception during GET: {e}\")\n            return None\n\n    def update_blob(self, data):\n        \"\"\"\n        Update the JSON Blob with new data.\n\n        Args:\n            data (dict): The new JSON data to store.\n\n        Returns:\n            bool: True if update is successful, else False.\n        \"\"\"\n        if not self.blob_id:\n            print(\"Blob ID is not set.\")\n            return False\n\n        try:\n            response = requests.put(\n                self.base_url,\n                headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n                data=json.dumps(data)\n            )\n            if response.status_code == 200:\n                #print(\"Blob updated successfully.\")\n                return True\n            elif response.status_code == 404:\n                print(\"Blob not found.\")\n                return False\n            else:\n                print(f\"Error updating blob: {response.status_code} - {response.text}\")\n                return False\n        except Exception as e:\n            print(f\"Exception during PUT: {e}\")\n            return False\n\n    def delete_blob(self):\n        \"\"\"\n        Delete the JSON Blob.\n\n        Returns:\n            bool: True if deletion is successful, else False.\n        \"\"\"\n        if not self.blob_id:\n            print(\"Blob ID is not set.\")\n            return False\n\n        try:\n            response = requests.delete(\n                self.base_url,\n                headers={\"Accept\": \"application/json\"}\n            )\n            if response.status_code == 200:\n                print(\"Blob deleted successfully.\")\n                self.blob_id = None\n                self.base_url = JSONBLOB_API_URL\n                return True\n            elif response.status_code == 404:\n                print(\"Blob not found.\")\n                return False\n            elif response.status_code == 405:\n                print(\"Deleting blobs is not enabled.\")\n                return False\n            else:\n                print(f\"Error deleting blob: {response.status_code} - {response.text}\")\n                return False\n        except Exception as e:\n            print(f\"Exception during DELETE: {e}\")\n            return False\n\n    def get_custom_url(self, custom_path):\n        \"\"\"\n        Retrieve blob data using a custom URL path.\n\n        Args:\n            custom_path (str): The custom URL path after /api/.\n\n        Returns:\n            dict: The JSON data if retrieval is successful, else None.\n        \"\"\"\n        custom_url = f\"https://jsonblob.com/api/{custom_path}\"\n        try:\n            response = requests.get(\n                custom_url,\n                headers={\"Accept\": \"application/json\"}\n            )\n            if response.status_code == 200:\n                print(\"Blob retrieved successfully using custom URL.\")\n                return response.json()\n            elif response.status_code == 404:\n                print(\"Blob not found at the custom URL.\")\n                return None\n            else:\n                print(f\"Error retrieving blob via custom URL: {response.status_code} - {response.text}\")\n                return None\n        except Exception as e:\n            print(f\"Exception during GET with custom URL: {e}\")\n            return None\n\n    def set_blob_id(self, blob_id):\n        \"\"\"\n        Set the blob ID manually.\n\n        Args:\n            blob_id (str): The blob ID to set.\n        \"\"\"\n        self.blob_id = blob_id\n        self.base_url = f\"{JSONBLOB_API_URL}/{self.blob_id}\"\n        print(f\"Blob ID set to: {self.blob_id}\")\n"
        },
        {
            "file_path": "performances/dirty_rect_manager.py",
            "content": "#File:  src/performances/dirty_rect_manager.py \u00a9 2025 projectemergence. All rights reserved.\nimport pygame\nfrom collections import deque\n\nclass DirtyRectManager:\n    \"\"\"\n    Minimal API:\n      \u2022 update()  \u2013 advance internal frame, rotate queues\n      \u2022 add(r, p=0) \u2013 schedule rect r with optional priority p\n      \u2022 draw(target, surf, pos=(0,0), p=0) \u2013 blit+add in one call\n      \u2022 flush()   \u2013 pygame.display.update() on all due rects\n    Everything else (buckets, history, frame-skip) is internal.\n    \"\"\"\n    def __init__(self, frame_skip: int = 1, hold_frames: int = 1):\n        self._fs = max(1, frame_skip)\n        self._hg = max(0, hold_frames)\n        self._buckets = [[] for _ in range(self._fs)]\n        self._hist = deque(maxlen=self._hg + 1)\n        for _ in range(self._hg + 1): self._hist.append([])\n        self._fi = 0\n\n    def update(self):\n        \"\"\"Rotate: move current bucket \u2192 history, clear it, advance frame index.\"\"\"\n        self._hist.append(self._buckets[self._fi])\n        self._buckets[self._fi] = []\n        self._fi = (self._fi + 1) % self._fs\n\n    def add(self, rect: pygame.Rect, p: int = 0):\n        \"\"\"Schedule `rect` for redraw on frame (current + p) % frame_skip.\"\"\"\n        idx = (self._fi + p) % self._fs\n        self._buckets[idx].append(rect)\n\n    def draw(self, target: pygame.Surface, surf: pygame.Surface,\n             pos: tuple[int,int]=(0,0), p: int = 0):\n        \"\"\"\n        Blit `surf` onto `target` at `pos`, then add the resulting Rect().\n        Optional `p` routes it into a future bucket.\n        \"\"\"\n        r = target.blit(surf, pos)\n        self.add(r, p)\n\n    def flush(self):\n        \"\"\"Gather history + current bucket, issue a single pygame.display.update().\"\"\"\n        rects = []\n        for past in self._hist:\n            rects.extend(past)\n        rects.extend(self._buckets[self._fi])\n        if rects:\n            pygame.display.update(rects)\n"
        },
        {
            "file_path": "performances/efficiencymeter.py",
            "content": "#File:  src/performances/efficiencymeter.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python\n\"\"\"\nEfficiencymeter Full: Report-Only Version for Monitoring a Pygame-based Game\n\nFeatures:\n- Two modes: 'test' for a single run test, 'session' for long-run monitoring.\n- Launches the game from src/main.py.\n- Monitors process metrics: CPU usage, memory usage, GPU usage (using GPUtil if available).\n- Monitors all cache folders (any directory with 'cache' in its name) within the src directory,\n  tracking file count and cumulative size to help detect memory leaks.\n- Does not display real-time graphs; instead, it generates a full report (printed to console and saved as CSV)\n  after the game run ends or if a crash occurs.\n- Scans all .py files in src for cyclomatic complexity using radon.\n- Exports CSV reports for both runtime metrics and source code complexity.\n\nDependencies:\n- psutil\n- pandas\n- radon\n- GPUtil (install via 'pip install GPUtil' for GPU monitoring)\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport threading\nimport subprocess\nimport argparse\nimport psutil\nimport tracemalloc\nimport pandas as pd\nfrom radon.complexity import cc_visit\n\ntry:\n    import GPUtil\nexcept ImportError:\n    GPUtil = None\n\n# Global dictionary to collect metrics over time.\nmetrics_data = {\n    \"timestamp\": [],\n    \"cpu\": [],\n    \"memory\": [],\n    \"gpu\": [],\n    \"cache_count\": [],\n    \"cache_size\": []\n}\n\n# Flag to control monitoring loop.\nmonitoring_active = True\n\ndef get_all_cache_metrics(src_dir):\n    \"\"\"\n    Recursively scans the src directory for any folder with 'cache' in its name (case-insensitive)\n    and aggregates the metrics:\n      - total file count\n      - total size in MB of all files within those folders.\n    \"\"\"\n    total_size = 0\n    file_count = 0\n    for root, dirs, _ in os.walk(src_dir):\n        for d in dirs:\n            if \"cache\" in d.lower():\n                cache_path = os.path.join(root, d)\n                for r, _, files in os.walk(cache_path):\n                    file_count += len(files)\n                    for f in files:\n                        f_path = os.path.join(r, f)\n                        if os.path.isfile(f_path):\n                            total_size += os.path.getsize(f_path)\n    total_size_mb = total_size / (1024 * 1024)\n    return file_count, total_size_mb\n\ndef monitor_process(pid, src_dir):\n    \"\"\"\n    Monitors the process with the given PID:\n      - CPU usage (with a 1-second sampling interval)\n      - Memory usage (in MB)\n      - GPU usage (in percent, if GPUtil is available)\n      - Cache folder metrics aggregated from any directory with 'cache' in its name in src_dir\n    Appends the results to the global metrics_data dictionary.\n    \"\"\"\n    global monitoring_active\n    try:\n        process = psutil.Process(pid)\n    except psutil.NoSuchProcess:\n        print(\"Error: Process not found!\")\n        return\n\n    start_time = time.time()\n    while monitoring_active and process.is_running():\n        try:\n            timestamp = time.time() - start_time\n            cpu_usage = process.cpu_percent(interval=1)\n            memory_usage = process.memory_info().rss / (1024 * 1024)  # MB\n\n            # GPU monitoring using GPUtil (if available)\n            if GPUtil:\n                try:\n                    gpus = GPUtil.getGPUs()\n                    if gpus:\n                        gpu_usage = sum(gpu.load for gpu in gpus) / len(gpus) * 100\n                    else:\n                        gpu_usage = 0\n                except Exception as e:\n                    print(\"GPU monitoring error:\", e)\n                    gpu_usage = 0\n            else:\n                gpu_usage = 0\n\n            # Aggregate metrics from all cache folders found within src_dir.\n            cache_count, cache_size = get_all_cache_metrics(src_dir)\n\n            # Append current metrics.\n            metrics_data[\"timestamp\"].append(timestamp)\n            metrics_data[\"cpu\"].append(cpu_usage)\n            metrics_data[\"memory\"].append(memory_usage)\n            metrics_data[\"gpu\"].append(gpu_usage)\n            metrics_data[\"cache_count\"].append(cache_count)\n            metrics_data[\"cache_size\"].append(cache_size)\n        except (psutil.NoSuchProcess, psutil.AccessDenied) as e:\n            print(\"Monitoring error:\", e)\n            break\n\ndef scan_complexity(src_dir):\n    \"\"\"\n    Scans all Python (.py) files in src_dir recursively,\n    computing the cyclomatic complexity using radon.\n    Returns a list of tuples: (file_path, complexity).\n    \"\"\"\n    complexities = []\n    for root, _, files in os.walk(src_dir):\n        for file in files:\n            if file.endswith(\".py\"):\n                file_path = os.path.join(root, file)\n                try:\n                    with open(file_path, 'r', encoding=\"utf-8\") as f:\n                        code = f.read()\n                    file_complexity = sum(c.complexity for c in cc_visit(code))\n                    complexities.append((file_path, file_complexity))\n                except Exception as e:\n                    complexities.append((file_path, f\"Error: {e}\"))\n    return complexities\n\ndef run_game_and_monitor(src_dir):\n    \"\"\"\n    Launches the game (src/main.py) and monitors its performance:\n      - Starts a background thread to sample process, GPU, and cache folder metrics.\n      - Waits for the game process to finish (or crash).\n      - Returns the collected metrics.\n    \"\"\"\n    global monitoring_active\n\n    game_entry = os.path.join(src_dir, \"main.py\")\n    if not os.path.isfile(game_entry):\n        print(\"Error: main.py not found in the provided src directory!\")\n        sys.exit(1)\n\n    # Start tracemalloc if needed (psutil already provides real-time memory usage)\n    tracemalloc.start()\n\n    # Launch the game process. Redirect output to DEVNULL to prevent blocking.\n    game_process = subprocess.Popen(\n        [sys.executable, game_entry],\n        stdout=subprocess.DEVNULL,\n        stderr=subprocess.DEVNULL\n    )\n\n    # Start a monitoring thread.\n    monitor_thread = threading.Thread(target=monitor_process, args=(game_process.pid, src_dir), daemon=True)\n    monitor_thread.start()\n\n    # Wait for the game process to finish (or crash).\n    try:\n        game_process.wait()\n    except KeyboardInterrupt:\n        print(\"Game run interrupted by user.\")\n    finally:\n        monitoring_active = False\n        monitor_thread.join()\n        tracemalloc.stop()\n\n    return metrics_data\n\ndef run_single_test(src_dir):\n    \"\"\"\n    Runs the game in single test mode:\n      - Executes the game and monitors performance in the background.\n      - After the run (or crash), scans the src directory for code complexity.\n      - Exports CSV reports for runtime metrics and source code complexity.\n      - Prints summary reports to the console.\n    \"\"\"\n    print(\"Running single test mode...\")\n    metrics = run_game_and_monitor(src_dir)\n    complexities = scan_complexity(src_dir)\n\n    df_metrics = pd.DataFrame(metrics)\n    df_complexity = pd.DataFrame(complexities, columns=[\"File\", \"Complexity\"])\n\n    df_metrics.to_csv(\"session_metrics_report.csv\", index=False)\n    df_complexity.to_csv(\"src_complexity_report.csv\", index=False)\n\n    print(\"Reports generated: session_metrics_report.csv and src_complexity_report.csv\")\n    print(\"\\n--- Session Metrics Report (First 10 Rows) ---\")\n    print(df_metrics.head(10))\n    print(\"\\n--- Source Code Complexity Report (First 10 Rows) ---\")\n    print(df_complexity.head(10))\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"Efficiencymeter for Monitoring a Pygame-based Game (Report-Only Version)\"\n    )\n    parser.add_argument(\"mode\", choices=[\"test\", \"session\"],\n                        help=\"Mode: 'test' for a single run, 'session' for long-run monitoring.\")\n    parser.add_argument(\"src_dir\",\n                        help=\"Path to the game source directory (should contain main.py and any cache folders).\")\n\n    args = parser.parse_args()\n\n    if args.mode == \"test\":\n        run_single_test(args.src_dir)\n    elif args.mode == \"session\":\n        print(\"Running long session mode. Press Ctrl+C to interrupt and finalize the report.\")\n        try:\n            run_game_and_monitor(args.src_dir)\n        except KeyboardInterrupt:\n            print(\"Session interrupted. Finalizing report...\")\n        finally:\n            complexities = scan_complexity(args.src_dir)\n            df_metrics = pd.DataFrame(metrics_data)\n            df_complexity = pd.DataFrame(complexities, columns=[\"File\", \"Complexity\"])\n            df_metrics.to_csv(\"session_metrics_report.csv\", index=False)\n            df_complexity.to_csv(\"src_complexity_report.csv\", index=False)\n            print(\"Reports generated: session_metrics_report.csv and src_complexity_report.csv\")\n            print(\"\\n--- Session Metrics Report (First 10 Rows) ---\")\n            print(df_metrics.head(10))\n            print(\"\\n--- Source Code Complexity Report (First 10 Rows) ---\")\n            print(df_complexity.head(10))\n"
        },
        {
            "file_path": "performances/graphics_analyser.py",
            "content": "#File:  src/performances/graphics_analyser.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python\n\"\"\"\nGraphics Analyser for Pygame Projects\n\nFeatures:\n- Recursively searches a given directory for all Python (.py) files.\n- Scans each file for lines containing Pygame drawing-related functions\n  such as those starting with \"pygame.draw\", \"pygame.display.flip/update\", or any \".blit(\", \".flip(\", \".update(\" calls.\n- Collects details including file name, line number, matched keyword/pattern, and code snippet.\n- Exports a CSV report (\"graphics_analysis_report.csv\") and prints a summary to the console.\n\nDependencies:\n- pandas\n- re (built-in)\n\"\"\"\n\nimport os\nimport re\nimport sys\nimport argparse\nimport pandas as pd\n\n# Define regex patterns for common pygame drawing functions.\n# You can refine these patterns to reduce false positives.\npatterns = {\n    \"pygame_draw\": re.compile(r\"pygame\\.draw\\.\\w+\\(\"),\n    \"pygame_display_flip\": re.compile(r\"pygame\\.display\\.flip\\(\"),\n    \"pygame_display_update\": re.compile(r\"pygame\\.display\\.update\\(\"),\n    \"blit\": re.compile(r\"\\.blit\\(\"),\n    \"flip\": re.compile(r\"\\.flip\\(\"),\n    \"update\": re.compile(r\"\\.update\\(\"),\n}\n\ndef analyse_file(file_path):\n    \"\"\"\n    Scans a single file for drawing-related function calls.\n    Returns a list of dictionaries with the file name, line number, matched pattern, and code snippet.\n    \"\"\"\n    results = []\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\") as f:\n            lines = f.readlines()\n    except Exception as e:\n        print(f\"Error reading {file_path}: {e}\")\n        return results\n\n    for idx, line in enumerate(lines, start=1):\n        # Check each pattern on the line.\n        for pattern_name, pattern in patterns.items():\n            if pattern.search(line):\n                results.append({\n                    \"File\": file_path,\n                    \"Line\": idx,\n                    \"Keyword\": pattern_name,\n                    \"Code Snippet\": line.strip()\n                })\n                # If a line matches multiple patterns, you may get duplicates.\n                # To avoid duplicates per line, uncomment the next line:\n                # break\n    return results\n\ndef analyse_directory(directory):\n    \"\"\"\n    Recursively scans the directory for .py files and analyses each one.\n    Returns a list of all findings.\n    \"\"\"\n    all_results = []\n    for root, _, files in os.walk(directory):\n        for file in files:\n            if file.endswith(\".py\"):\n                full_path = os.path.join(root, file)\n                file_results = analyse_file(full_path)\n                all_results.extend(file_results)\n    return all_results\n\ndef main(directory):\n    print(f\"Analysing Python files in directory: {directory}\")\n    results = analyse_directory(directory)\n    \n    if not results:\n        print(\"No drawing-related function calls found.\")\n        return\n    \n    df = pd.DataFrame(results)\n    report_file = \"graphics_analysis_report.csv\"\n    df.to_csv(report_file, index=False)\n    \n    print(f\"\\nGraphics analysis report saved as: {report_file}\")\n    print(\"\\n--- Report Summary (First 10 Rows) ---\")\n    print(df.head(10).to_string(index=False))\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"Graphics Analyser for Pygame Projects: Scans for drawing-related functions (draw, blit, flip, update, etc.).\"\n    )\n    parser.add_argument(\"directory\", help=\"Path to the project directory to analyse.\")\n    args = parser.parse_args()\n    main(args.directory)\n"
        },
        {
            "file_path": "performances/project_analyser.py",
            "content": "#File:  src/performances/project_analyser.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python\n\"\"\"\nProject Analyser UI\n\u00a9 2024 projectemergence. All rights reserved.\n\nThis UI integrates four analysis tools:\n  1. Efficiency Meter \u2013 Monitors a Pygame-based game (expects main.py) and saves performance reports.\n  2. Runtime Tester \u2013 Measures the wall\u2011clock runtime of each code file.\n  3. Graphics Analyser \u2013 Searches for Pygame drawing calls (draw, blit, flip, update, etc.) in Python files.\n  4. Project Summariser \u2013 Summarises the project folder (only code files: .py, .php, .html, .js, .css, .ts) \n     by generating a JSON report and a concatenated file with proper comment markers.\n     \nReports are saved in \"reports\" inside the current directory (src/performances/reports).\n\nThe UI also provides a Reports Viewer to load CSV files and display them as sortable tables.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport threading\nimport subprocess\nimport psutil\nimport tracemalloc\nimport re\nimport json\nimport ast\nfrom datetime import datetime\nimport pandas as pd\nimport tkinter as tk\nfrom tkinter import filedialog, scrolledtext, messagebox, ttk\nfrom radon.complexity import cc_visit\n\ntry:\n    import GPUtil\nexcept ImportError:\n    GPUtil = None\n\n# ---------- Helper Functions & Global Variables ----------\n\ndef get_reports_dir(base_dir):\n    reports_dir = os.path.join(base_dir, \"reports\")\n    os.makedirs(reports_dir, exist_ok=True)\n    return reports_dir\n\n# Allowed code file extensions for summarisation.\nALLOWED_EXTENSIONS = {\".py\", \".php\", \".html\", \".js\", \".css\", \".ts\"}\n\ndef get_comment_marker(ext):\n    mapping = {\n        \".py\": \"#\",\n        \".php\": \"//\",\n        \".html\": \"<!--\",\n        \".js\": \"//\",\n        \".css\": \"/*\",\n        \".ts\": \"//\"\n    }\n    return mapping.get(ext, \"#\")\n\ndef get_version_from_path(file_path):\n    parts = file_path.split(os.sep)\n    for part in parts:\n        if part.startswith(\"ALLV\") and part[4:].isdigit():\n            return part\n    return \"ALLV_unknown\"\n\ndef extract_function_details(file_content):\n    \"\"\"Extract function names, arguments, and return statements from Python file content.\"\"\"\n    try:\n        tree = ast.parse(file_content)\n        functions = []\n        for node in ast.walk(tree):\n            if isinstance(node, ast.FunctionDef):\n                args = [arg.arg for arg in node.args.args]\n                returns = [ast.dump(n.value) for n in ast.walk(node) if isinstance(n, ast.Return) and n.value is not None]\n                functions.append((node.name, args, returns))\n        return functions\n    except SyntaxError:\n        return []\n\n# ---------- Efficiency Meter Functions ----------\n\ndef get_all_cache_metrics(src_dir):\n    total_size = 0\n    file_count = 0\n    for root, dirs, _ in os.walk(src_dir):\n        for d in dirs:\n            if \"cache\" in d.lower():\n                cache_path = os.path.join(root, d)\n                for r, _, files in os.walk(cache_path):\n                    file_count += len(files)\n                    for f in files:\n                        f_path = os.path.join(r, f)\n                        if os.path.isfile(f_path):\n                            total_size += os.path.getsize(f_path)\n    total_size_mb = total_size / (1024 * 1024)\n    return file_count, total_size_mb\n\ndef monitor_process(pid, src_dir, log_func, metrics_data):\n    try:\n        process = psutil.Process(pid)\n    except psutil.NoSuchProcess:\n        log_func(\"Error: Process not found!\")\n        return\n    start_time = time.time()\n    while metrics_data.get(\"monitoring_active\", True) and process.is_running():\n        try:\n            timestamp = time.time() - start_time\n            cpu_usage = process.cpu_percent(interval=1)\n            memory_usage = process.memory_info().rss / (1024 * 1024)\n            if GPUtil:\n                try:\n                    gpus = GPUtil.getGPUs()\n                    gpu_usage = sum(gpu.load for gpu in gpus) / len(gpus) * 100 if gpus else 0\n                except Exception as e:\n                    log_func(f\"GPU monitoring error: {e}\")\n                    gpu_usage = 0\n            else:\n                gpu_usage = 0\n            cache_count, cache_size = get_all_cache_metrics(src_dir)\n            metrics_data[\"timestamp\"].append(timestamp)\n            metrics_data[\"cpu\"].append(cpu_usage)\n            metrics_data[\"memory\"].append(memory_usage)\n            metrics_data[\"gpu\"].append(gpu_usage)\n            metrics_data[\"cache_count\"].append(cache_count)\n            metrics_data[\"cache_size\"].append(cache_size)\n        except (psutil.NoSuchProcess, psutil.AccessDenied) as e:\n            log_func(f\"Monitoring error: {e}\")\n            break\n\ndef scan_complexity(src_dir):\n    complexities = []\n    for root, _, files in os.walk(src_dir):\n        for file in files:\n            if file.endswith(\".py\"):\n                file_path = os.path.join(root, file)\n                try:\n                    with open(file_path, 'r', encoding=\"utf-8\") as f:\n                        code = f.read()\n                    file_complexity = sum(c.complexity for c in cc_visit(code))\n                    complexities.append((file_path, file_complexity))\n                except Exception as e:\n                    complexities.append((file_path, f\"Error: {e}\"))\n    return complexities\n\ndef run_efficiency_meter(src_dir, log_func, reports_dir):\n    log_func(\"Starting Efficiency Meter (launching game)...\")\n    metrics_data = {\"timestamp\": [], \"cpu\": [], \"memory\": [], \"gpu\": [], \"cache_count\": [], \"cache_size\": []}\n    metrics_data[\"monitoring_active\"] = True\n    game_entry = os.path.join(src_dir, \"main.py\")\n    if not os.path.isfile(game_entry):\n        log_func(\"Error: main.py not found in the selected directory!\")\n        return\n    tracemalloc.start()\n    game_process = subprocess.Popen(\n        [sys.executable, game_entry],\n        stdout=subprocess.DEVNULL,\n        stderr=subprocess.DEVNULL\n    )\n    monitor_thread = threading.Thread(target=monitor_process, args=(game_process.pid, src_dir, log_func, metrics_data), daemon=True)\n    monitor_thread.start()\n    try:\n        game_process.wait()\n    except KeyboardInterrupt:\n        log_func(\"Game run interrupted by user.\")\n    finally:\n        metrics_data[\"monitoring_active\"] = False\n        monitor_thread.join()\n        tracemalloc.stop()\n    complexities = scan_complexity(src_dir)\n    df_metrics = pd.DataFrame(metrics_data)\n    df_complexity = pd.DataFrame(complexities, columns=[\"File\", \"Complexity\"])\n    metrics_file = os.path.join(reports_dir, \"session_metrics_report.csv\")\n    complexity_file = os.path.join(reports_dir, \"src_complexity_report.csv\")\n    df_metrics.to_csv(metrics_file, index=False)\n    df_complexity.to_csv(complexity_file, index=False)\n    log_func(f\"Efficiency Meter reports generated:\\n - {metrics_file}\\n - {complexity_file}\")\n\n# ---------- Runtime Tester Functions ----------\n\ndef test_runtime(file_path, timeout=10):\n    start = time.perf_counter()\n    try:\n        subprocess.run(\n            [sys.executable, file_path],\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.DEVNULL,\n            timeout=timeout\n        )\n        end = time.perf_counter()\n        return end - start\n    except subprocess.TimeoutExpired:\n        return \"Timeout\"\n    except Exception as e:\n        return f\"Error: {e}\"\n\ndef run_runtime_tester(src_dir, timeout, log_func, reports_dir):\n    results = []\n    for root, _, files in os.walk(src_dir):\n        for file in files:\n            if file.endswith(\".py\"):\n                full_path = os.path.join(root, file)\n                if os.path.abspath(full_path) == os.path.abspath(__file__):\n                    continue\n                log_func(f\"Testing: {full_path}\")\n                runtime = test_runtime(full_path, timeout=timeout)\n                results.append({\"File\": full_path, \"Runtime (s)\": runtime})\n    df = pd.DataFrame(results)\n    report_file = os.path.join(reports_dir, \"runtime_test_report.csv\")\n    df.to_csv(report_file, index=False)\n    log_func(f\"Runtime Tester completed. Report generated:\\n - {report_file}\")\n\n# ---------- Graphics Analyser Functions ----------\n\n# Regex patterns for common pygame drawing functions.\ngraphics_patterns = {\n    \"pygame_draw\": re.compile(r\"pygame\\.draw\\.\\w+\\(\"),\n    \"pygame_display_flip\": re.compile(r\"pygame\\.display\\.flip\\(\"),\n    \"pygame_display_update\": re.compile(r\"pygame\\.display\\.update\\(\"),\n    \"blit\": re.compile(r\"\\.blit\\(\"),\n    \"flip\": re.compile(r\"\\.flip\\(\"),\n    \"update\": re.compile(r\"\\.update\\(\"),\n}\n\ndef analyse_file(file_path):\n    results = []\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\") as f:\n            lines = f.readlines()\n    except Exception:\n        return results\n    for idx, line in enumerate(lines, start=1):\n        for pattern_name, pattern in graphics_patterns.items():\n            if pattern.search(line):\n                results.append({\n                    \"File\": file_path,\n                    \"Line\": idx,\n                    \"Keyword\": pattern_name,\n                    \"Code Snippet\": line.strip()\n                })\n    return results\n\ndef run_graphics_analyser(src_dir, log_func, reports_dir):\n    all_results = []\n    for root, _, files in os.walk(src_dir):\n        for file in files:\n            if file.endswith(\".py\"):\n                full_path = os.path.join(root, file)\n                file_results = analyse_file(full_path)\n                all_results.extend(file_results)\n    if not all_results:\n        log_func(\"No drawing-related function calls found.\")\n        return\n    df = pd.DataFrame(all_results)\n    report_file = os.path.join(reports_dir, \"graphics_analysis_report.csv\")\n    df.to_csv(report_file, index=False)\n    log_func(f\"Graphics Analyser completed. Report generated:\\n - {report_file}\")\n\n# ---------- Project Summariser Functions ----------\n\ndef save_folder_structure(root_folder, output_file, concatenated_output):\n    file_structure = {}\n    function_definitions = {}\n    all_imports = set()\n    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')\n    # Open the concatenated file for writing.\n    with open(concatenated_output, \"w\", encoding=\"utf-8\") as concat_file:\n        # Write header with current year.\n        concat_file.write(f\"\u00a9 {datetime.now().year} projectemergence. All rights reserved.\\n\\n\")\n        for dirpath, dirnames, filenames in os.walk(root_folder):\n            # Skip __pycache__ and report/saves directories.\n            dirnames[:] = [d for d in dirnames if d not in {\"__pycache__\", \"reports\", \"saves\"}]\n            rel_path = os.path.relpath(dirpath, root_folder)\n            if rel_path == \".\": rel_path = \"\"\n            file_structure[rel_path] = []\n            for file in filenames:\n                ext = os.path.splitext(file)[1].lower()\n                if ext in ALLOWED_EXTENSIONS:\n                    file_path = os.path.join(dirpath, file)\n                    try:\n                        with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                            file_content = f.read()\n                    except Exception:\n                        file_content = \"\"\n                    file_structure[rel_path].append({\"name\": file, \"content\": file_content, \"timestamp\": timestamp})\n                    if ext == \".py\":\n                        functions = extract_function_details(file_content)\n                        function_definitions[file_path] = functions\n                    # Write file content to concatenated file with appropriate comment header.\n                    marker = get_comment_marker(ext)\n                    concat_file.write(f\"{marker} File: {file_path}\\n\")\n                    for line in file_content.splitlines():\n                        # For code files, we assume the content is code.\n                        concat_file.write(f\"{marker} {line}\\n\")\n                    concat_file.write(\"\\n\\n\")\n    # Save the main report as JSON.\n    with open(output_file, \"w\", encoding=\"utf-8\") as outfile:\n        json.dump(file_structure, outfile, indent=4)\n    # Save a supplementary file with directory tree and function details.\n    supplementary_output_file = output_file.replace(\".txt\", \"_ProjectTree.txt\")\n    with open(supplementary_output_file, \"w\", encoding=\"utf-8\") as sfile:\n        for dirpath, dirnames, files in os.walk(root_folder):\n            dirnames[:] = [d for d in dirnames if d not in {\"__pycache__\", \"reports\", \"saves\"}]\n            rel_path = os.path.relpath(dirpath, root_folder)\n            if rel_path == \".\": rel_path = \"\"\n            sfile.write(f\"Directory: {rel_path}\\n\")\n            for file in files:\n                ext = os.path.splitext(file)[1].lower()\n                if ext in ALLOWED_EXTENSIONS:\n                    file_path = os.path.join(dirpath, file)\n                    sfile.write(f\"  File: {file}\\n\")\n                    if file_path in function_definitions:\n                        sfile.write(\"    Functions:\\n\")\n                        for func_name, args, return_values in function_definitions[file_path]:\n                            args_str = \", \".join(args)\n                            returns_str = \", \".join(return_values)\n                            sfile.write(f\"      {func_name}({args_str}) -> {returns_str}\\n\")\n            sfile.write(\"\\n\")\n    log_msg = (f\"Folder structure saved to {output_file}\\n\"\n               f\"Supplementary file saved to {supplementary_output_file}\\n\"\n               f\"Concatenated file saved to {concatenated_output}\")\n    return log_msg\n\ndef summarise_project(root_folder, reports_dir, log_func):\n    version = get_version_from_path(os.path.abspath(__file__))\n    output_file = os.path.join(reports_dir, f\"{version}report_{datetime.now().strftime('%Y%m%d%H%M%S')}.txt\")\n    concatenated_output = os.path.join(reports_dir, f\"{version}_concatenated_{datetime.now().strftime('%Y%m%d%H%M%S')}.py\")\n    msg = save_folder_structure(root_folder, output_file, concatenated_output)\n    log_func(\"Project Summariser completed:\")\n    log_func(msg)\n\n# ---------- UI Code ----------\n\nclass ProjectAnalyserUI(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\"Project Analyser UI\")\n        self.geometry(\"800x600\")\n        # Base directory is assumed to be the parent of this script\u2019s directory.\n        self.base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__)))\n        self.reports_dir = get_reports_dir(self.base_dir)\n        self.create_widgets()\n\n    def create_widgets(self):\n        # Directory selection.\n        dir_frame = tk.Frame(self)\n        dir_frame.pack(pady=8)\n        tk.Label(dir_frame, text=\"Select Project Directory:\").pack(side=tk.LEFT, padx=5)\n        self.dir_entry = tk.Entry(dir_frame, width=60)\n        self.dir_entry.pack(side=tk.LEFT, padx=5)\n        tk.Button(dir_frame, text=\"Browse\", command=self.browse_directory).pack(side=tk.LEFT, padx=5)\n        # Analysis buttons.\n        btn_frame = tk.Frame(self)\n        btn_frame.pack(pady=8)\n        tk.Button(btn_frame, text=\"Run Efficiency Meter\", width=25, command=self.run_efficiency).pack(pady=4)\n        tk.Button(btn_frame, text=\"Run Runtime Tester\", width=25, command=self.run_runtime).pack(pady=4)\n        tk.Button(btn_frame, text=\"Run Graphics Analyser\", width=25, command=self.run_graphics).pack(pady=4)\n        tk.Button(btn_frame, text=\"Summarise Project\", width=25, command=self.run_summariser).pack(pady=4)\n        tk.Button(btn_frame, text=\"View Reports\", width=25, command=self.view_reports).pack(pady=4)\n        # Log output.\n        self.log_widget = scrolledtext.ScrolledText(self, width=95, height=20)\n        self.log_widget.pack(pady=10)\n        self.log(\"Project Analyser UI started.\")\n\n    def browse_directory(self):\n        directory = filedialog.askdirectory()\n        if directory:\n            self.dir_entry.delete(0, tk.END)\n            self.dir_entry.insert(0, directory)\n\n    def log(self, message):\n        self.log_widget.insert(tk.END, f\"{message}\\n\")\n        self.log_widget.see(tk.END)\n\n    def run_efficiency(self):\n        src_dir = self.dir_entry.get().strip()\n        if not os.path.isdir(src_dir):\n            messagebox.showerror(\"Error\", \"Please select a valid directory.\")\n            return\n        self.log(\"Launching Efficiency Meter...\")\n        threading.Thread(target=run_efficiency_meter, args=(src_dir, self.log, self.reports_dir), daemon=True).start()\n\n    def run_runtime(self):\n        src_dir = self.dir_entry.get().strip()\n        if not os.path.isdir(src_dir):\n            messagebox.showerror(\"Error\", \"Please select a valid directory.\")\n            return\n        self.log(\"Launching Runtime Tester (timeout=10s)...\")\n        threading.Thread(target=run_runtime_tester, args=(src_dir, 10, self.log, self.reports_dir), daemon=True).start()\n\n    def run_graphics(self):\n        src_dir = self.dir_entry.get().strip()\n        if not os.path.isdir(src_dir):\n            messagebox.showerror(\"Error\", \"Please select a valid directory.\")\n            return\n        self.log(\"Launching Graphics Analyser...\")\n        threading.Thread(target=run_graphics_analyser, args=(src_dir, self.log, self.reports_dir), daemon=True).start()\n\n    def run_summariser(self):\n        src_dir = self.dir_entry.get().strip()\n        if not os.path.isdir(src_dir):\n            messagebox.showerror(\"Error\", \"Please select a valid directory.\")\n            return\n        self.log(\"Launching Project Summariser...\")\n        # For summariser, we use the project root as the folder to summarise.\n        threading.Thread(target=summarise_project, args=(src_dir, self.reports_dir, self.log), daemon=True).start()\n\n    def view_reports(self):\n        ReportViewer(self.reports_dir)\n\nclass ReportViewer(tk.Toplevel):\n    def __init__(self, reports_dir):\n        super().__init__()\n        self.title(\"Reports Viewer\")\n        self.geometry(\"900x600\")\n        self.reports_dir = reports_dir\n        self.create_widgets()\n\n    def create_widgets(self):\n        top_frame = tk.Frame(self)\n        top_frame.pack(fill=tk.X, pady=5)\n        tk.Label(top_frame, text=\"Select CSV Report:\").pack(side=tk.LEFT, padx=5)\n        self.report_var = tk.StringVar()\n        self.report_combo = ttk.Combobox(top_frame, textvariable=self.report_var, width=50)\n        self.report_combo.pack(side=tk.LEFT, padx=5)\n        tk.Button(top_frame, text=\"Load Report\", command=self.load_report).pack(side=tk.LEFT, padx=5)\n        # Table frame.\n        self.tree = ttk.Treeview(self, columns=[], show=\"headings\")\n        self.tree.pack(fill=tk.BOTH, expand=True)\n        # Attach a vertical scrollbar.\n        vsb = ttk.Scrollbar(self, orient=\"vertical\", command=self.tree.yview)\n        vsb.pack(side='right', fill='y')\n        self.tree.configure(yscrollcommand=vsb.set)\n        self.populate_report_list()\n\n    def populate_report_list(self):\n        files = [f for f in os.listdir(self.reports_dir) if f.endswith(\".csv\")]\n        self.report_combo['values'] = files\n        if files:\n            self.report_combo.current(0)\n\n    def load_report(self):\n        filename = self.report_var.get()\n        if not filename:\n            messagebox.showerror(\"Error\", \"No report selected.\")\n            return\n        filepath = os.path.join(self.reports_dir, filename)\n        try:\n            df = pd.read_csv(filepath)\n        except Exception as e:\n            messagebox.showerror(\"Error\", f\"Could not load CSV: {e}\")\n            return\n        # Clear existing tree.\n        for col in self.tree.get_children():\n            self.tree.delete(col)\n        self.tree[\"columns\"] = list(df.columns)\n        for col in df.columns:\n            self.tree.heading(col, text=col, command=lambda _col=col: self.sortby(_col, False))\n            self.tree.column(col, width=100)\n        # Insert rows.\n        for index, row in df.iterrows():\n            self.tree.insert(\"\", \"end\", values=list(row))\n    \n    def sortby(self, col, descending):\n        # Grab all values to sort.\n        data = [(self.tree.set(child, col), child) for child in self.tree.get_children('')]\n        try:\n            data.sort(key=lambda t: float(t[0]) if t[0] not in {\"Timeout\", \"Error\"} else float('inf'), reverse=descending)\n        except ValueError:\n            data.sort(reverse=descending)\n        for index, item in enumerate(data):\n            self.tree.move(item[1], '', index)\n        # Reverse sort next time.\n        self.tree.heading(col, command=lambda: self.sortby(col, not descending))\n\nif __name__ == \"__main__\":\n    app = ProjectAnalyserUI()\n    app.mainloop()\n"
        },
        {
            "file_path": "performances/runtime_tester.py",
            "content": "#File:  src/performances/runtime_tester.py \u00a9 2025 projectemergence. All rights reserved.\n#!/usr/bin/env python\n\"\"\"\nRuntime Tester for Python Files\n\nFeatures:\n- Recursively searches the specified directory for all .py files (except itself).\n- Executes each file using the current Python interpreter.\n- Measures the wall-clock runtime for each file.\n- Uses a configurable timeout (default: 10 seconds) to avoid hangs.\n- Generates a CSV report (\"runtime_test_report.csv\") and prints a summary to the console.\n\nDependencies:\n- pandas\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport subprocess\nimport argparse\nimport pandas as pd\n\ndef test_runtime(file_path, timeout=10):\n    \"\"\"\n    Runs the given Python file and measures its execution time.\n    \n    Parameters:\n        file_path (str): Path to the Python file.\n        timeout (int): Maximum allowed seconds for file execution.\n        \n    Returns:\n        float or str: Runtime in seconds or \"Timeout/Error\" if execution failed.\n    \"\"\"\n    start = time.perf_counter()\n    try:\n        subprocess.run(\n            [sys.executable, file_path],\n            stdout=subprocess.DEVNULL,\n            stderr=subprocess.DEVNULL,\n            timeout=timeout\n        )\n        end = time.perf_counter()\n        return end - start\n    except subprocess.TimeoutExpired:\n        return \"Timeout\"\n    except Exception as e:\n        print(f\"Error running {file_path}: {e}\")\n        return \"Error\"\n\ndef main(directory, timeout=10):\n    results = []\n    for root, _, files in os.walk(directory):\n        for file in files:\n            if file.endswith(\".py\"):\n                full_path = os.path.join(root, file)\n                # Skip the runtime tester itself if it's in the same directory.\n                if os.path.abspath(full_path) == os.path.abspath(__file__):\n                    continue\n                print(f\"Testing {full_path}...\")\n                runtime = test_runtime(full_path, timeout=timeout)\n                results.append({\n                    \"File\": full_path,\n                    \"Runtime (s)\": runtime\n                })\n    df = pd.DataFrame(results)\n    report_file = \"runtime_test_report.csv\"\n    df.to_csv(report_file, index=False)\n    print(\"\\nRuntime test report saved as:\", report_file)\n    print(\"\\n--- Summary ---\")\n    print(df)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Runtime Tester for Python Files\")\n    parser.add_argument(\"directory\", help=\"Directory to search for Python files\")\n    parser.add_argument(\"--timeout\", type=int, default=10, help=\"Timeout in seconds for each file execution (default: 10)\")\n    args = parser.parse_args()\n    main(args.directory, timeout=args.timeout)\n"
        },
        {
            "file_path": "performances/shutdown_manager.py",
            "content": "#File:  src/performances/shutdown_manager.py \u00a9 2025 projectemergence. All rights reserved.\nimport os\nimport sys\nimport shutil\nimport logging\nimport multiprocessing\nimport signal\nimport pygame\nimport time\n\n# --- Cache clearing functionality ---\ndef clear_python_cache():\n    \"\"\"\n    Recursively remove __pycache__ directories and .pyc files\n    from the current working directory.\n    \"\"\"\n    cwd = os.getcwd()\n    for root, dirs, files in os.walk(cwd):\n        for d in dirs:\n            if d == '__pycache__':\n                cache_dir = os.path.join(root, d)\n                try:\n                    shutil.rmtree(cache_dir)\n                    logging.debug(f\"Deleted cache directory: {cache_dir}\")\n                except Exception as e:\n                    logging.warning(f\"Error deleting cache directory {cache_dir}: {e}\")\n        for f in files:\n            if f.endswith('.pyc'):\n                file_path = os.path.join(root, f)\n                try:\n                    os.remove(file_path)\n                    logging.debug(f\"Deleted cache file: {file_path}\")\n                except Exception as e:\n                    logging.warning(f\"Error deleting cache file {file_path}: {e}\")\n\ndef clear_all_caches(is_executable: bool):\n    \"\"\"\n    Clears python caches and resets the log file.\n    \"\"\"\n    clear_python_cache()\n    log_file_path = 'dev_app.log'\n    try:\n        # Overwrite log file to clear it out.\n        # with open(log_file_path, 'w'):\n        #     pass\n        logging.debug(f\"Cleared log file: {log_file_path}\")\n    except Exception as e:\n        logging.warning(f\"Error clearing log file {log_file_path}: {e}\")\n\ndef is_running_as_executable() -> bool:\n    \"\"\"\n    Determine if the application is running as a bundled executable.\n    \"\"\"\n    return getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS')\n\n\n# --- Graceful shutdown functionality ---\ndef graceful_shutdown(thread_manager, audio_client):\n    \"\"\"\n    Gracefully shutdown the application by:\n      - Stopping the audio engine.\n      - Joining managed threads.\n      - Shutting down any physics solver executor.\n      - Terminating and killing active multiprocess children.\n      - Clearing caches and quitting pygame.\n      - Exiting the application.\n    \"\"\"\n    logging.info(\"Initiating graceful shutdown...\")\n\n    # 1) Stop the audio engine client.\n    try:\n        audio_client.stop()\n        logging.info(\"Audio engine client stopped gracefully.\")\n    except Exception as e:\n        logging.warning(f\"Error stopping audio engine client: {e}\")\n\n    # 2) Join managed threads.\n    try:\n        # Wait for each thread to finish gracefully\n        for thread_name in thread_manager.list_threads():\n            thread_manager.wait_for_thread(thread_name)\n        logging.info(\"All managed threads have been joined.\")\n    except Exception as e:\n        logging.warning(f\"Error joining threads in thread_manager: {e}\")\n\n    # 3) Shutdown any custom executors (e.g., physics solver).\n    try:\n        from core.inventory.melt.physics_solver import shutdown_solver_executor\n        shutdown_solver_executor()\n        logging.info(\"Physics solver executor shut down.\")\n    except ImportError:\n        # No physics solver module, ignore\n        pass\n    except Exception as e:\n        logging.warning(f\"Error shutting down solver executor: {e}\")\n\n    # 4) Ensure proper file permissions and delete problematic file\n    try:\n        file_path = 'C:\\\\Users\\\\lierm\\\\pa_retrieve_host_apis'\n        # Change permissions to allow deletion\n        os.chmod(file_path, 0o777)  # Grant full permissions\n        os.remove(file_path)  # Delete the file\n        logging.info(f\"Deleted file {file_path} after changing permissions.\")\n    except Exception as e:\n        logging.warning(f\"Error deleting file {file_path}: {e}\")\n\n    # 5) Terminate and kill any active multiprocessing children.\n    active = multiprocessing.active_children()\n    if active:\n        logging.info(f\"Found {len(active)} active child process(es). Terminating...\")\n        for proc in active:\n            try:\n                proc.terminate()\n                logging.info(f\"Terminated child process pid={proc.pid}\")\n            except Exception as e:\n                logging.warning(f\"Error terminating process pid={proc.pid}: {e}\")\n        # Wait briefly and then force-kill remaining alive processes\n        for proc in active:\n            proc.join(timeout=2)\n            if proc.is_alive():\n                try:\n                    proc.kill()\n                    logging.info(f\"Killed child process pid={proc.pid}\")\n                except Exception as e:\n                    logging.warning(f\"Failed to kill process pid={proc.pid}: {e}\")\n    else:\n        logging.info(\"No active multiprocessing child processes found.\")\n\n    # 6) Clear caches and logs.\n    clear_all_caches(is_executable=is_running_as_executable())\n\n    # 7) Quit pygame and exit immediately.\n    try:\n        pygame.quit()\n    except Exception as e:\n        logging.warning(f\"Error quitting pygame: {e}\")\n    sys.exit(0)\n\n\n\n"
        },
        {
            "file_path": "performances/summary.py",
            "content": "#File:  src/performances/summary.py \u00a9 2025 projectemergence. All rights reserved.\n#File:  src/performances/summary.py \u00a9 2024 projectemergence. All rights reserved.\nimport os\nimport json\nfrom datetime import datetime\nimport ast\n\ndef get_version_from_path(file_path):\n    parts = file_path.split(os.sep)\n    for part in parts:\n        if part.startswith(\"ALLV\") and part[4:].isdigit():\n            return part\n    return \"ALLV_unknown\"\n\ndef extract_function_details(file_content):\n    \"\"\"Extract function names, arguments, and return statements from a given file content.\"\"\"\n    try:\n        tree = ast.parse(file_content)\n        functions = []\n        for node in ast.walk(tree):\n            if isinstance(node, ast.FunctionDef):\n                args = [arg.arg for arg in node.args.args]\n                returns = [n.value for n in ast.walk(node) if isinstance(n, ast.Return) and n.value is not None]\n                return_values = [ast.dump(r) for r in returns]\n                functions.append((node.name, args, return_values))\n        return functions\n    except SyntaxError as e:\n        #print(f\"Syntax error while parsing file content: {e}\")\n        return []\n\ndef save_folder_structure(root_folder, output_file, concatenated_output):\n    file_structure = {}\n    function_definitions = {}\n    all_imports = set()\n    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')\n\n    with open(concatenated_output, \"w\", encoding=\"utf-8\") as concat_file:\n        for dirpath, dirnames, filenames in os.walk(root_folder):\n            # Skip __pycache__ directories\n            dirnames[:] = [d for d in dirnames if d != \"__pycache__\"]\n\n            rel_path = os.path.relpath(dirpath, root_folder)\n\n            # Skip the ALLVx/Reports directory\n            if 'ALLV' in rel_path and 'Reports' in rel_path:\n                continue\n            if 'reports' in rel_path:\n                continue\n            if 'saves' in rel_path:\n                continue\n\n            if rel_path == \".\":\n                rel_path = \"\"\n            file_structure[rel_path] = []\n\n            for file in filenames:\n                if file.endswith(\".py\") or file.endswith(\".ini\") or file.endswith(\".json\"):\n                    file_path = os.path.join(dirpath, file)\n                    try:\n                        with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                            file_content = f.read()\n                    except Exception as e:\n                        #print(f\"Error reading file {file_path}: {e}\")\n                        file_content = \"\"\n                    \n                    # Save file content to the main report\n                    file_structure[rel_path].append({\"name\": file, \"content\": file_content, \"timestamp\": timestamp})\n\n                    # Extract function details for Python files\n                    if file.endswith(\".py\"):\n                        functions = extract_function_details(file_content)\n                        function_definitions[file_path] = functions\n\n                        # Append Python file content to concatenated file\n                        concat_file.write(f\"# File: {file_path}\\n\")\n                        for line in file_content.splitlines():\n                            if line.startswith(\"import\") or line.startswith(\"from\"):\n                                if line not in all_imports:\n                                    concat_file.write(f\"{line}\\n\")\n                                    all_imports.add(line)\n                            elif line.strip() and not line.strip().startswith(\"#\"):  # Avoid comments and empty lines\n                                concat_file.write(f\"{line}\\n\")\n                        concat_file.write(\"\\n\\n\")\n\n    # Save the main report file\n    with open(output_file, \"w\", encoding=\"utf-8\") as outfile:\n        json.dump(file_structure, outfile, indent=4)\n    \n    # Save the supplementary file with directory tree and function details\n    supplementary_output_file = output_file.replace(\".txt\", \"_ProjectTree.txt\")\n    with open(supplementary_output_file, \"w\", encoding=\"utf-8\") as sfile:\n        for dirpath, dirnames, files in os.walk(root_folder):\n            # Skip __pycache__ directories\n            dirnames[:] = [d for d in dirnames if d != \"__pycache__\"]\n            \n            rel_path = os.path.relpath(dirpath, root_folder)\n            if 'reports' in rel_path:\n                continue\n            if 'saves' in rel_path:\n                continue\n            if rel_path == \".\":\n                rel_path = \"\"\n            sfile.write(f\"Directory: {rel_path}\\n\")\n            for file in files:\n                if file.endswith(\".py\") or file.endswith(\".ini\") or file.endswith(\".json\"):\n                    file_path = os.path.join(dirpath, file)\n                    sfile.write(f\"  File: {file}\\n\")\n                    if file_path in function_definitions:\n                        sfile.write(\"    Functions:\\n\")\n                        for func_name, args, return_values in function_definitions[file_path]:\n                            args_str = \", \".join(args)\n                            returns_str = \", \".join(return_values)\n                            sfile.write(f\"      {func_name}({args_str}) -> {returns_str}\\n\")\n            sfile.write(\"\\n\")\n    \n    print(f\"Folder structure and files saved to {output_file}\")\n    print(f\"Supplementary file with directory tree and function details saved to {supplementary_output_file}\")\n    print(f\"Concatenated Python file saved to {concatenated_output}\")\n\nif __name__ == \"__main__\":\n    script_path = os.path.abspath(__file__)\n    version = get_version_from_path(script_path)\n\n    root_folder = os.path.abspath(os.path.join(script_path, \"../..\"))  # Adjusted to be relative to script's location\n    reports_dir = os.path.join(root_folder, \"Reports\")\n    os.makedirs(reports_dir, exist_ok=True)\n\n    output_file = os.path.join(reports_dir, f\"{version}report_{datetime.now().strftime('%Y%m%d%H%M%S')}.txt\")\n    concatenated_output = os.path.join(reports_dir, f\"{version}_concatenated_{datetime.now().strftime('%Y%m%d%H%M%S')}.py\")\n\n    save_folder_structure(root_folder, output_file, concatenated_output)\n"
        },
        {
            "file_path": "performances/thread_manager.py",
            "content": "#File:  src/thread_manager.py \u00a9 2025 projectemergence. All rights reserved.\n#File:  src/thread_manager.py \u00a9 2024 projectemergence. All rights reserved.\nimport sys\nimport threading\nimport queue\nimport logging\nimport multiprocessing\nimport time\nimport linecache\n\n# Removed trace_lines and sys.settrace usage for cleaner execution.\n\nclass ThreadManager:\n    \"\"\"\n    A generalized Thread Manager to supervise threaded tasks in your application.\n    It can cap the maximum number of concurrent threads based on CPU core/thread count\n    or run in single-thread mode. Tasks can be started immediately or queued if the limit\n    is reached. Provides methods to start, stop, list, check, wait, clear, and log threads.\n    \"\"\"\n\n    def __init__(self, single_thread=False, max_threads=None, logger=None):\n        \"\"\"\n        :param single_thread: If True, forces only one thread to run at a time.\n        :param max_threads: Maximum number of threads allowed at once. \n                            If None, this will default to the CPU count.\n        :param logger: Provide a custom logger, else uses default logging.\n        \"\"\"\n        self.logger = logger or logging.getLogger(__name__)\n        self.logger.setLevel(logging.DEBUG)\n\n        # If single-thread mode is requested, override everything to 1\n        if single_thread:\n            self.max_threads = 1\n        else:\n            # If max_threads is not given, fall back to the system CPU count\n            self.max_threads = max_threads if max_threads else multiprocessing.cpu_count()\n\n        self.threads = {}         # thread_name -> threading.Thread object\n        self.thread_queue = queue.Queue()  # queue of tasks (thread_name, target, args, kwargs, daemon)\n        self.thread_lock = threading.Lock()  # lock to protect shared resources\n\n        # A simple sentinel to notify we have an available slot if the manager is not saturated\n        self.available_slot = threading.Event()\n        self.available_slot.set()  # initially, we assume we have a free slot to start at least one thread\n\n    def _thread_worker(self, thread_name, target, args, kwargs):\n        # Removed sys.settrace(None) call since tracing is disabled.\n        try:\n            self.logger.info(f\"Thread '{thread_name}' started.\")\n            target(*args, **kwargs)\n        except Exception as e:\n            self.logger.exception(f\"Exception in thread '{thread_name}': {e}\")\n        finally:\n            self._cleanup_thread(thread_name)\n\n    def _cleanup_thread(self, thread_name):\n        \"\"\"\n        Internal method to remove the thread from the dictionary upon completion\n        and then attempt to process any waiting tasks from the queue.\n        \"\"\"\n        with self.thread_lock:\n            if thread_name in self.threads:\n                self.logger.info(f\"Thread '{thread_name}' is completing cleanup.\")\n                del self.threads[thread_name]\n\n            # Process the next task from the queue if any are waiting\n            if not self.thread_queue.empty():\n                next_thread = self.thread_queue.get_nowait()\n                self._start_thread_internal(*next_thread)\n            else:\n                # If the queue is empty, set the available_slot to True\n                self.available_slot.set()\n\n    def _can_start_thread(self):\n        \"\"\"\n        Check if we are below the max_threads limit.\n        \"\"\"\n        with self.thread_lock:\n            return len(self.threads) < self.max_threads\n\n    def _start_thread_internal(self, thread_name, target, args, kwargs, daemon):\n        \"\"\"\n        Internal method that actually starts the thread object.\n        Assumes we have capacity or it will be queued again.\n        \"\"\"\n        with self.thread_lock:\n            if thread_name in self.threads:\n                self.logger.warning(f\"Thread '{thread_name}' already exists and is alive.\")\n                return\n\n            # Create the actual thread\n            thread = threading.Thread(\n                target=self._thread_worker,\n                args=(thread_name, target, args, kwargs),\n                daemon=daemon\n            )\n            self.threads[thread_name] = thread\n            thread.start()\n            self.logger.debug(f\"Started thread '{thread_name}' internally.\")\n\n            # If we've reached capacity, clear available_slot\n            if len(self.threads) >= self.max_threads:\n                self.available_slot.clear()\n\n    def start_thread(self, thread_name, target, *args, daemon=False, **kwargs):\n        \"\"\"\n        Public method to start a new thread.\n        If maximum threads are running, it will queue the thread until a slot is available.\n        \"\"\"\n        with self.thread_lock:\n            # If already running, skip\n            if thread_name in self.threads:\n                self.logger.warning(f\"Thread '{thread_name}' is already running.\")\n                return\n\n            # If there's room to start a new thread\n            if self._can_start_thread():\n                self._start_thread_internal(thread_name, target, args, kwargs, daemon)\n            else:\n                # Otherwise, queue it\n                self.thread_queue.put((thread_name, target, args, kwargs, daemon))\n                self.logger.info(f\"Queued thread '{thread_name}' (max capacity reached).\")\n\n    def stop_thread(self, thread_name, timeout=2):\n        \"\"\"\n        Attempt to stop a thread by joining it (voluntary finish).\n        This method depends on whether the target function can exit gracefully.\n        \"\"\"\n        with self.thread_lock:\n            if thread_name in self.threads:\n                thread = self.threads[thread_name]\n                if thread.is_alive():\n                    self.logger.info(f\"Joining thread '{thread_name}' with timeout={timeout}.\")\n                    thread.join(timeout=timeout)\n                # After join, if it's still alive, there's no forced kill in pure Python threads\n                if thread.is_alive():\n                    self.logger.warning(f\"Thread '{thread_name}' is still running after join.\")\n                else:\n                    self.logger.info(f\"Thread '{thread_name}' has stopped.\")\n                if thread_name in self.threads:\n                    del self.threads[thread_name]\n\n    def wait_for_thread(self, thread_name):\n        \"\"\"\n        Block until the specified thread is finished.\n        \"\"\"\n        thread = None\n        with self.thread_lock:\n            thread = self.threads.get(thread_name, None)\n        if thread is not None:\n            thread.join()\n            self.logger.info(f\"Thread '{thread_name}' has finished waiting.\")\n\n    def check_thread(self, thread_name):\n        \"\"\"\n        Check if a thread is alive.\n        \"\"\"\n        with self.thread_lock:\n            thread = self.threads.get(thread_name)\n            return thread.is_alive() if thread else False\n\n    def list_threads(self):\n        \"\"\"\n        List all thread names currently in the manager.\n        \"\"\"\n        with self.thread_lock:\n            return list(self.threads.keys())\n\n    def list_thread_status(self):\n        \"\"\"\n        Return a dictionary of thread_name -> bool (is_alive).\n        \"\"\"\n        status = {}\n        with self.thread_lock:\n            for name, th in self.threads.items():\n                status[name] = th.is_alive()\n        return status\n\n    def clear_all_threads(self):\n        \"\"\"\n        Join and remove all threads from the manager.\n        \"\"\"\n        with self.thread_lock:\n            thread_names = list(self.threads.keys())\n        for name in thread_names:\n            self.stop_thread(name)\n        self.logger.info(\"Cleared all threads from the manager.\")\n\n    def process_queue(self):\n        \"\"\"\n        Attempt to process queued threads (if there's capacity).\n        You can call this periodically or let the manager do it automatically upon thread completion.\n        \"\"\"\n        # Keep pulling from the queue while we have capacity\n        while not self.thread_queue.empty() and self._can_start_thread():\n            with self.thread_lock:\n                thread_info = self.thread_queue.get_nowait()\n            self._start_thread_internal(*thread_info)\n\n    def log_threads(self):\n        \"\"\"\n        Helper to log the current threads and their statuses.\n        \"\"\"\n        statuses = self.list_thread_status()\n        self.logger.info(\"Current Threads:\")\n        for thread_name, alive in statuses.items():\n            self.logger.info(f\"  {thread_name}: {'Alive' if alive else 'Not Alive'}\")\n\n    def wait_for_all(self):\n        \"\"\"\n        Wait for all threads currently in the manager to finish.\n        \"\"\"\n        names = self.list_threads()\n        for name in names:\n            self.wait_for_thread(name)\n\n    @staticmethod\n    def get_cpu_count():\n        \"\"\"\n        Returns the number of CPUs available on the system.\n        \"\"\"\n        return multiprocessing.cpu_count()\n"
        },
        {
            "file_path": "performances/reports/graphics_analysis_report.csv",
            "content": "Asset file: graphics_analysis_report.csv"
        },
        {
            "file_path": "performances/reports/runtime_test_report.csv",
            "content": "Asset file: runtime_test_report.csv"
        },
        {
            "file_path": "performances/reports/session_metrics_report.csv",
            "content": "Asset file: session_metrics_report.csv"
        },
        {
            "file_path": "performances/reports/src_complexity_report.csv",
            "content": "Asset file: src_complexity_report.csv"
        }
    ]
}